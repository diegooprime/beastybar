<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Beasty Bar Simulator</title>
    <style>
      :root {
        color-scheme: light;
        --surface: #ffffff;
        --surface-muted: #f5f7fa;
        --surface-strong: #111827;
        --border: #d0d7de;
        --text: #111827;
        --subtle-text: #64748b;
        --accent-blue: #2563eb;
        --accent-orange: #f97316;
        --queue-gradient: linear-gradient(90deg, rgba(37, 99, 235, 0.08), rgba(249, 115, 22, 0.08));
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--surface-muted);
        color: var(--text);
        min-height: 100vh;
      }

      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      button {
        font: inherit;
        cursor: pointer;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        padding: 0.45rem 0.95rem;
        transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
      }

      button:hover {
        background: #eef2ff;
        box-shadow: 0 6px 14px rgba(37, 99, 235, 0.15);
      }

      button:focus-visible {
        outline: 3px solid rgba(37, 99, 235, 0.35);
        outline-offset: 2px;
      }

      input[type="number"] {
        font: inherit;
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 0.45rem 0.9rem;
        width: 140px;
        background: var(--surface);
      }

      .top-bar {
        position: sticky;
        top: 0;
        z-index: 10;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        padding: 1.25rem 1.75rem 1rem;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.65));
        backdrop-filter: blur(12px);
        border-bottom: 1px solid rgba(209, 213, 219, 0.6);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.65rem;
      }

      .status-block {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.5rem;
        min-width: 260px;
      }

      .turn-indicator {
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .score-line {
        color: var(--subtle-text);
        font-size: 0.95rem;
      }

      .hint {
        margin: 0;
        padding: 0 1.75rem 0.75rem;
        color: var(--subtle-text);
        font-size: 0.9rem;
        min-height: 1.1rem;
      }

      .scoreboard {
        display: flex;
        align-items: center;
        gap: 0.8rem;
      }

      .score-card {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        padding: 0.6rem 0.9rem;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .score-card__name {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--subtle-text);
      }

      .score-card__value {
        font-size: 1.5rem;
        font-weight: 700;
        line-height: 1.1;
      }

      .score-card--leader {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 14px 30px rgba(37, 99, 235, 0.18);
      }

      .score-card[data-player="1"].score-card--leader {
        border-color: rgba(249, 115, 22, 0.45);
        box-shadow: 0 14px 30px rgba(249, 115, 22, 0.18);
      }

      .score-card--trailing {
        opacity: 0.75;
      }

      .score-card--tied {
        border-style: dashed;
      }

      .score-card--active {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 12px 22px rgba(37, 99, 235, 0.16);
      }

      .score-card[data-player="1"].score-card--active {
        border-color: rgba(249, 115, 22, 0.45);
        box-shadow: 0 12px 22px rgba(249, 115, 22, 0.16);
      }

      .score-card--winner {
        border-width: 2px;
        transform: translateY(-4px);
        background: rgba(37, 99, 235, 0.12);
        box-shadow: 0 18px 34px rgba(37, 99, 235, 0.28);
      }

      .score-card[data-player="1"].score-card--winner {
        background: rgba(249, 115, 22, 0.12);
        box-shadow: 0 18px 34px rgba(249, 115, 22, 0.28);
      }

      .main {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        align-items: stretch;
        justify-content: center;
        gap: 1.5rem;
        padding: 1.5rem 1.75rem 2.25rem;
      }

      .board {
        flex: 1 1 640px;
        display: grid;
        grid-template-columns: 220px minmax(0, 1fr) 220px;
        gap: 1.5rem;
        align-items: stretch;
      }

      .pile {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 0.65rem;
        padding: 1.2rem 1rem;
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: var(--surface);
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
        min-height: 260px;
      }

      .pile:hover {
        transform: translateY(-3px);
        box-shadow: 0 30px 60px rgba(30, 64, 175, 0.25);
      }

      .pile-label {
        font-weight: 650;
        font-size: 1.05rem;
        letter-spacing: 0.015em;
        text-transform: uppercase;
      }

      .pile-count {
        font-size: 0.85rem;
        color: var(--subtle-text);
      }

      .pile-preview {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        align-items: stretch;
      }

      .pile-mini-card {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem 0.65rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        background: rgba(248, 250, 252, 0.9);
        box-shadow: 0 6px 12px rgba(15, 23, 42, 0.08);
        font-weight: 600;
        color: var(--subtle-text);
        font-size: 0.85rem;
      }

      .pile-mini-card[data-owner="0"] {
        border-color: rgba(37, 99, 235, 0.55);
        color: rgba(37, 99, 235, 0.85);
      }

      .pile-mini-card[data-owner="1"] {
        border-color: rgba(249, 115, 22, 0.55);
        color: rgba(249, 115, 22, 0.85);
      }

      .pile-mini-card__owner {
        font-size: 0.75rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: inherit;
      }

      .pile-mini-card--summary,
      .pile-mini-card--placeholder {
        justify-content: center;
        color: var(--subtle-text);
        border-style: dashed;
        box-shadow: none;
      }

      .pile-mini-card--summary {
        font-size: 0.8rem;
      }

      .queue-area {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
      }

      .queue-label {
        font-weight: 600;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: var(--subtle-text);
      }

      .queue-track {
        flex: 1;
        min-height: 260px;
        border-radius: 22px;
        border: 1px dashed rgba(148, 163, 184, 0.6);
        background: var(--queue-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        padding: 1.25rem 1rem;
        position: relative;
      }

      .queue-track::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 1.1rem;
        right: 1.1rem;
        height: 4px;
        background: linear-gradient(90deg, rgba(37, 99, 235, 0.25), rgba(249, 115, 22, 0.25));
        border-radius: 999px;
        transform: translateY(-50%);
        pointer-events: none;
      }

      .queue-cards {
        display: flex;
        gap: 1.25rem;
        align-items: flex-start;
        justify-content: center;
        z-index: 1;
      }

      .cards-empty {
        padding: 0.65rem 1rem;
        border-radius: 12px;
        border: 1px dashed rgba(148, 163, 184, 0.65);
        background: rgba(255, 255, 255, 0.64);
        color: var(--subtle-text);
        font-size: 0.9rem;
      }

      .card {
        position: relative;
        width: 148px;
        min-height: 190px;
        border-radius: 18px;
        border: 2px solid rgba(148, 163, 184, 0.45);
        background: var(--surface);
        padding: 0.75rem 0.85rem;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
      }

      .card.player-0 {
        border-color: rgba(37, 99, 235, 0.6);
        box-shadow: 0 18px 35px rgba(37, 99, 235, 0.15);
      }

      .card.player-1 {
        border-color: rgba(249, 115, 22, 0.6);
        box-shadow: 0 18px 35px rgba(249, 115, 22, 0.15);
      }

      .card--queue {
        min-height: 170px;
        width: 140px;
      }

      .card--subtle {
        background: rgba(248, 250, 252, 0.9);
        border-style: dashed;
        color: var(--subtle-text);
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
      }

      .card--playable {
        box-shadow: 0 26px 52px rgba(37, 99, 235, 0.25);
        transform: translateY(-6px);
      }

      .card--playable:hover {
        transform: translateY(-8px);
      }

      .card:hover {
        transform: translateY(-4px);
      }

      .card--clickable {
        cursor: pointer;
      }

      .card--selected {
        border-width: 3px;
        transform: translateY(-10px);
      }

      .card.player-0.card--selected {
        border-color: rgba(37, 99, 235, 0.75);
        box-shadow: 0 30px 58px rgba(37, 99, 235, 0.26);
      }

      .card.player-1.card--selected {
        border-color: rgba(249, 115, 22, 0.75);
        box-shadow: 0 30px 58px rgba(249, 115, 22, 0.26);
      }

      .card--targetable {
        cursor: pointer;
        border-width: 3px;
        transform: translateY(-8px);
        box-shadow: 0 30px 60px rgba(37, 99, 235, 0.25);
      }

      .card.player-1.card--targetable {
        box-shadow: 0 30px 60px rgba(249, 115, 22, 0.25);
        border-color: rgba(249, 115, 22, 0.7);
      }

      .card--targetable:hover {
        transform: translateY(-10px);
      }

      .card--dimmed {
        opacity: 0.35;
        pointer-events: none;
      }

      .card-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
      }

      .card-strength {
        font-size: 2.4rem;
        font-weight: 700;
        line-height: 1;
      }

      .card-points {
        min-width: 48px;
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        background: rgba(17, 24, 39, 0.85);
        color: #f8fafc;
        font-size: 0.85rem;
        text-align: center;
        font-weight: 600;
      }

      .card-points.negative {
        background: rgba(220, 38, 38, 0.85);
      }

      .card-species {
        font-weight: 650;
        font-size: 1.05rem;
        text-transform: capitalize;
      }

      .card-actions {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .card-actions button {
        width: 100%;
        margin: 0;
        border-radius: 12px;
        padding: 0.4rem 0.5rem;
        font-size: 0.85rem;
      }

      .hands {
        position: sticky;
        bottom: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1rem;
        padding: 1.25rem 1.75rem 1.75rem;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.85));
        backdrop-filter: blur(18px);
        border-top: 1px solid rgba(209, 213, 219, 0.6);
      }

      .hand {
        background: var(--surface);
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        padding: 1rem 1.1rem;
        box-shadow: 0 15px 32px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }

      .hand-active {
        box-shadow: 0 28px 55px rgba(37, 99, 235, 0.25);
        transform: translateY(-6px);
      }

      .hand-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: var(--subtle-text);
      }

      .hand-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 0.85rem;
      }

      .log {
        flex: 0 0 260px;
        display: flex;
        flex-direction: column;
        background: var(--surface);
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        max-height: 100%;
        overflow: hidden;
      }

      .log-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.28);
      }

      .log h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: var(--subtle-text);
      }

      .log-toggle {
        padding: 0.35rem 0.8rem;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .log-list {
        list-style: none;
        margin: 0;
        padding: 1.2rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        overflow-y: auto;
      }

      .log-item {
        font-size: 0.9rem;
        color: var(--text);
        line-height: 1.35;
      }

      .log-item time {
        display: block;
        font-size: 0.75rem;
        color: var(--subtle-text);
        margin-bottom: 0.15rem;
      }

      .log-empty {
        color: var(--subtle-text);
        font-size: 0.85rem;
      }

      .log-collapsed {
        max-height: 3.25rem;
      }

      .log.log-collapsed .log-list {
        display: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 40;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
      }

      .modal-panel {
        position: relative;
        z-index: 1;
        width: min(720px, 90vw);
        max-height: 80vh;
        background: var(--surface);
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 40px 80px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      }

      .modal-title {
        margin: 0;
        font-size: 1.1rem;
      }

      .modal-body {
        padding: 1.25rem;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .modal-close {
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
      }

      .modal--open {
        display: flex;
      }

      @media (max-width: 1080px) {
        .board {
          grid-template-columns: minmax(0, 1fr);
        }

        .pile,
        .queue-track {
          min-height: 220px;
        }

        .queue-track {
          flex-wrap: wrap;
        }

        .log {
          flex: 1 1 100%;
          min-height: 240px;
          order: 2;
        }
      }

      @media (max-width: 640px) {
        .top-bar {
          padding-inline: 1.1rem;
        }

        .hint {
          margin-inline: 1.1rem;
        }

        .scoreboard {
          width: 100%;
          justify-content: space-between;
        }

        .main {
          padding-inline: 1.1rem;
        }

        .hands {
          padding-inline: 1.1rem;
        }

        .card {
          width: 140px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="top-bar">
        <div class="controls">
          <button id="new-game" type="button">New Game</button>
          <button id="new-seeded" type="button">New Seeded Game</button>
          <input id="seed-input" type="number" placeholder="Seed" />
        </div>
        <div class="status-block">
          <div id="status" class="turn-indicator">Loading…</div>
          <div class="scoreboard">
            <div id="score-card-0" class="score-card" data-player="0">
              <span class="score-card__name">Player 0</span>
              <span id="score-player-0" class="score-card__value">0</span>
            </div>
            <div id="score-card-1" class="score-card" data-player="1">
              <span class="score-card__name">Player 1</span>
              <span id="score-player-1" class="score-card__value">0</span>
            </div>
          </div>
          <div id="score" class="score-line"></div>
        </div>
      </header>
      <div id="hint" class="hint"></div>
      <div class="main">
        <section class="board">
          <button id="gate-pile" class="pile" type="button" data-pile="beastyBar">
            <div class="pile-label">Heaven's Gate</div>
            <div id="beasty-preview" class="pile-preview"></div>
            <div id="beasty-count" class="pile-count"></div>
          </button>
          <div class="queue-area">
            <div class="queue-label">Line to the Bar</div>
            <div class="queue-track">
              <div id="queue" class="queue-cards"></div>
            </div>
          </div>
          <button id="thats-it-pile" class="pile" type="button" data-pile="thatsIt">
            <div class="pile-label">THAT'S IT</div>
            <div id="thats-preview" class="pile-preview"></div>
            <div id="thats-count" class="pile-count"></div>
          </button>
        </section>
        <aside id="log" class="log">
          <div class="log-header">
            <h2>Turn Log</h2>
            <button id="log-toggle" type="button" class="log-toggle" aria-expanded="true">Collapse</button>
          </div>
          <ol id="log-list" class="log-list">
            <li class="log-empty">No turns yet</li>
          </ol>
        </aside>
      </div>
      <section class="hands">
        <div id="player-0" class="hand">
          <div class="hand-header">
            <span class="hand-name">Player 0</span>
          </div>
          <div id="hand-0" class="hand-cards"></div>
        </div>
        <div id="player-1" class="hand">
          <div class="hand-header">
            <span class="hand-name">Player 1</span>
          </div>
          <div id="hand-1" class="hand-cards"></div>
        </div>
      </section>
    </div>
    <div id="modal" class="modal" aria-hidden="true">
      <div id="modal-backdrop" class="modal-backdrop"></div>
      <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal-header">
          <h3 id="modal-title" class="modal-title">Pile</h3>
          <button id="modal-close" type="button" class="modal-close" aria-label="Close">×</button>
        </div>
        <div id="modal-body" class="modal-body"></div>
      </div>
    </div>
    <script>
      let currentState = null;
      let bootstrapped = false;
      let pileContents = { beastyBar: [], thatsIt: [] };
      let eventLog = [];
      let pendingSelection = null;

      const statusEl = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const scoreCardEls = [document.getElementById("score-card-0"), document.getElementById("score-card-1")];
      const scoreValueEls = [document.getElementById("score-player-0"), document.getElementById("score-player-1")];
      const queueEl = document.getElementById("queue");
      const handWrappers = [document.getElementById("player-0"), document.getElementById("player-1")];
      const handContainers = [document.getElementById("hand-0"), document.getElementById("hand-1")];
      const hintEl = document.getElementById("hint");

      const newGameBtn = document.getElementById("new-game");
      const newSeedBtn = document.getElementById("new-seeded");
      const seedInput = document.getElementById("seed-input");

      const gatePileBtn = document.getElementById("gate-pile");
      const thatsPileBtn = document.getElementById("thats-it-pile");
      const beastyPreview = document.getElementById("beasty-preview");
      const thatsPreview = document.getElementById("thats-preview");
      const beastyCount = document.getElementById("beasty-count");
      const thatsCount = document.getElementById("thats-count");

      const logEl = document.getElementById("log");
      const logToggleBtn = document.getElementById("log-toggle");
      const logList = document.getElementById("log-list");

      const modalEl = document.getElementById("modal");
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      const modalClose = document.getElementById("modal-close");
      const modalBackdrop = document.getElementById("modal-backdrop");

      newGameBtn.addEventListener("click", () => {
        eventLog = [];
        renderLog();
        if (pendingSelection) {
          clearSelection();
        }
        startNewGame({});
      });
      newSeedBtn.addEventListener("click", () => {
        const value = seedInput.value ? Number(seedInput.value) : null;
        eventLog = [];
        renderLog();
        if (pendingSelection) {
          clearSelection();
        }
        startNewGame({ seed: value ?? undefined });
      });

      gatePileBtn.addEventListener("click", () => openPileModal("Heaven's Gate", pileContents.beastyBar));
      thatsPileBtn.addEventListener("click", () => openPileModal("THAT'S IT", pileContents.thatsIt));
      modalClose.addEventListener("click", closeModal);
      modalBackdrop.addEventListener("click", closeModal);
      document.addEventListener("keydown", (event) => {
        if (event.key !== "Escape") {
          return;
        }
        if (modalEl.classList.contains("modal--open")) {
          closeModal();
          return;
        }
        if (pendingSelection) {
          clearSelection();
        }
      });

      logToggleBtn.addEventListener("click", () => {
        const collapsed = logEl.classList.toggle("log-collapsed");
        logToggleBtn.textContent = collapsed ? "Expand" : "Collapse";
        logToggleBtn.setAttribute("aria-expanded", String(!collapsed));
      });

      async function startNewGame(payload) {
        await fetch("/api/new-game", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload ?? {}),
        });
        bootstrapped = true;
        addLogEntry(`New game started${payload?.seed ? ` · Seed ${payload.seed}` : ""}`);
        await refreshState();
      }

      async function refreshState() {
        const response = await fetch("/api/state");
        if (response.ok) {
          currentState = await response.json();
          render();
        } else if (!bootstrapped) {
          await startNewGame({});
        } else {
          statusEl.textContent = "Create a game to begin.";
          clearRender();
        }
      }

      function render() {
        if (!currentState) {
          updateHint();
          return;
        }
        const { turn, activePlayer, isTerminal, seed, score, zones, queue, hands } = currentState;
        const runningScore = [0, 0];
        zones.beastyBar.forEach((card) => {
          runningScore[card.owner] += card.points;
        });
        const scoreLine = isTerminal && score ? score : runningScore;

        const displayedTurn = isTerminal ? turn : turn + 1;
        statusEl.textContent = isTerminal
          ? winnerMessage(scoreLine)
          : `Turn ${displayedTurn} · Player ${activePlayer} to play`;

        scoreValueEls.forEach((el, idx) => {
          el.textContent = scoreLine[idx];
        });

        scoreCardEls.forEach((cardEl, idx) => {
          cardEl.classList.remove(
            "score-card--leader",
            "score-card--trailing",
            "score-card--tied",
            "score-card--winner",
            "score-card--active",
          );
          if (!isTerminal && idx === activePlayer) {
            cardEl.classList.add("score-card--active");
          }
        });

        const scoreSummary = `P0 ${scoreLine[0]} – P1 ${scoreLine[1]}`;

        if (scoreLine[0] === scoreLine[1]) {
          scoreCardEls.forEach((cardEl) => cardEl.classList.add("score-card--tied"));
        } else {
          const leader = scoreLine[0] > scoreLine[1] ? 0 : 1;
          const trailer = leader === 0 ? 1 : 0;
          if (isTerminal) {
            scoreCardEls[leader].classList.add("score-card--winner");
            scoreCardEls[trailer].classList.add("score-card--trailing");
          } else {
            scoreCardEls[leader].classList.add("score-card--leader");
            scoreCardEls[trailer].classList.add("score-card--trailing");
          }
        }

        if (isTerminal) {
          scoreEl.textContent = `Final score · ${scoreSummary}`;
        } else if (seed) {
          scoreEl.textContent = `Seed ${seed} · ${scoreSummary}`;
        } else {
          scoreEl.textContent = `Running score · ${scoreSummary}`;
        }

        const legalByHand = new Map();
        currentState.legalActions.forEach((action) => {
          if (!legalByHand.has(action.handIndex)) {
            legalByHand.set(action.handIndex, []);
          }
          legalByHand.get(action.handIndex).push(action);
        });

        const queueTarget = getQueueTargetState();
        const queueNodes = queue.map((card, queueIndex) => {
          const tooltip = `Strength ${card.strength} · Points ${card.points} · Player ${card.owner}`;
          const targetable = queueTarget?.indices.has(queueIndex) ?? false;
          const dimmed = Boolean(queueTarget) && !targetable;
          return createCard(card, {
            queue: true,
            tooltip,
            queueIndex,
            targetable,
            dimmed,
            onClick: targetable ? () => handleQueueCardClick(queueIndex) : null,
          });
        });
        renderNodes(queueEl, queueNodes, { emptyText: "Queue empty" });

        pileContents = {
          beastyBar: zones.beastyBar,
          thatsIt: zones.thatsIt,
        };
        updatePilePreview(beastyPreview, beastyCount, zones.beastyBar);
        updatePilePreview(thatsPreview, thatsCount, zones.thatsIt);

        hands.forEach((hand, playerIndex) => {
          const wrapper = handWrappers[playerIndex];
          wrapper.classList.toggle("hand-active", playerIndex === activePlayer);
          const nodes = hand.map((card, handIndex) => {
            const actions = playerIndex === activePlayer ? legalByHand.get(handIndex) ?? [] : [];
            const isSelected =
              pendingSelection &&
              pendingSelection.handIndex === handIndex &&
              playerIndex === activePlayer;
            const inlineOptions =
              isSelected && pendingSelection.type === "kangaroo"
                ? pendingSelection.actions.map((action) => ({
                    label: kangarooLabel(action),
                    onSelect: () => sendSelectedAction(action),
                  }))
                : null;
            return createCard(card, {
              highlight: actions.length > 0 && playerIndex === activePlayer,
              selected: isSelected,
              handIndex,
              onClick:
                playerIndex === activePlayer && actions.length > 0
                  ? () => handleHandCardClick(card, handIndex, actions)
                  : null,
              inlineOptions,
            });
          });
          renderNodes(handContainers[playerIndex], nodes, { emptyText: "No cards in hand" });
        });

        updateHint();
      }

      function createCard(card, options = {}) {
        const {
          actions = [],
          subtle = false,
          highlight = false,
          queue = false,
          tooltip = "",
          selected = false,
          targetable = false,
          dimmed = false,
          onClick = null,
          handIndex = null,
          queueIndex = null,
          inlineOptions = null,
        } = options;
        const div = document.createElement("div");
        div.className = "card";
        div.classList.add(`player-${card.owner}`);
        if (queue) div.classList.add("card--queue");
        if (subtle) {
          div.classList.add("card--subtle");
        }
        if (highlight) {
          div.classList.add("card--playable");
        }
        if (selected) {
          div.classList.add("card--selected");
        }
        if (targetable) {
          div.classList.add("card--targetable");
        }
        if (dimmed) {
          div.classList.add("card--dimmed");
        }
        if (tooltip) {
          div.title = tooltip;
        }
        if (handIndex !== null) {
          div.dataset.handIndex = String(handIndex);
        }
        if (queueIndex !== null) {
          div.dataset.queueIndex = String(queueIndex);
        }
        if (onClick) {
          div.classList.add("card--clickable");
          div.setAttribute("role", "button");
          div.tabIndex = 0;
          div.addEventListener("click", (event) => {
            event.stopPropagation();
            onClick(event);
          });
          div.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              onClick(event);
            }
          });
        }

        const top = document.createElement("div");
        top.className = "card-top";
        const strength = document.createElement("div");
        strength.className = "card-strength";
        strength.textContent = card.strength;
        const points = document.createElement("span");
        points.className = "card-points";
        points.textContent = `${card.points >= 0 ? "+" : ""}${card.points}`;
        if (card.points < 0) {
          points.classList.add("negative");
        }
        top.appendChild(strength);
        top.appendChild(points);
        div.appendChild(top);

        const species = document.createElement("div");
        species.className = "card-species";
       species.textContent = card.species;
       div.appendChild(species);

        if (inlineOptions?.length) {
          const actionsEl = document.createElement("div");
          actionsEl.className = "card-actions";
          inlineOptions.forEach((option) => {
            const button = document.createElement("button");
            button.type = "button";
            button.textContent = option.label;
            button.addEventListener("click", (event) => {
              event.stopPropagation();
              option.onSelect();
            });
            actionsEl.appendChild(button);
          });
          div.appendChild(actionsEl);
        }

        return div;
      }

      function renderNodes(container, nodes, options = {}) {
        const { emptyText = "Empty" } = options;
        container.innerHTML = "";
        nodes.forEach((node) => container.appendChild(node));
        if (!nodes.length) {
          const empty = document.createElement("div");
          empty.className = "cards-empty";
          empty.textContent = emptyText;
          container.appendChild(empty);
        }
      }

      function updatePilePreview(previewEl, countEl, cards, options = {}) {
        const { emptyText = "Empty" } = options;
        previewEl.innerHTML = "";
        if (!cards.length) {
          const placeholder = document.createElement("div");
          placeholder.className = "pile-mini-card pile-mini-card--placeholder";
          placeholder.textContent = emptyText;
          previewEl.appendChild(placeholder);
          countEl.textContent = "";
          return;
        }

        const display = cards.slice(-4).reverse();
        const hidden = cards.length - display.length;

        if (hidden > 0) {
          const summary = document.createElement("div");
          summary.className = "pile-mini-card pile-mini-card--summary";
          summary.textContent = `+${hidden} more`;
          previewEl.appendChild(summary);
        }

        display.forEach((card) => {
          const mini = document.createElement("div");
          mini.className = "pile-mini-card";
          mini.dataset.owner = String(card.owner);
          const name = document.createElement("span");
          name.textContent = card.species;
          const owner = document.createElement("span");
          owner.className = "pile-mini-card__owner";
          owner.textContent = `P${card.owner}`;
          mini.appendChild(name);
          mini.appendChild(owner);
          previewEl.appendChild(mini);
        });
        countEl.textContent = `${cards.length} card${cards.length === 1 ? "" : "s"}`;
      }

      function kangarooLabel(action) {
        const hop = action.params?.[0] ?? 0;
        if (hop <= 0) {
          return "Stay put";
        }
        return hop === 1 ? "Hop 1 space" : `Hop ${hop} spaces`;
      }

      function getQueueTargetState() {
        if (!pendingSelection) {
          return null;
        }

        if (pendingSelection.type === "target") {
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[0];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices, step: "target", species: pendingSelection.species };
        }

        if (pendingSelection.type === "chameleon-extra") {
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[1];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices, step: "extra", species: "chameleon" };
        }

        return null;
      }

      function setSelection(selection) {
        pendingSelection = selection;
        render();
      }

      function clearSelection() {
        if (!pendingSelection) {
          return;
        }
        pendingSelection = null;
        render();
      }

      function handleHandCardClick(card, handIndex, actions) {
        if (!actions.length) {
          return;
        }

        if (pendingSelection && pendingSelection.handIndex === handIndex) {
          clearSelection();
          return;
        }

        const species = card.species;
        if (species === "parrot" || species === "chameleon") {
          setSelection({ type: "target", species, handIndex, actions });
          return;
        }

        if (species === "kangaroo") {
          const hopOptions = new Set(
            actions
              .filter((action) => action.params && action.params.length)
              .map((action) => action.params[0])
          );
          if (hopOptions.size > 1) {
            setSelection({ type: "kangaroo", species, handIndex, actions });
            return;
          }
        }

        sendSelectedAction(actions[0]);
      }

      function handleQueueCardClick(queueIndex) {
        if (!pendingSelection) {
          return;
        }

        if (pendingSelection.type === "target") {
          const matches = pendingSelection.actions.filter((action) => action.params?.[0] === queueIndex);
          if (!matches.length) {
            return;
          }

          if (pendingSelection.species === "chameleon") {
            const requiresExtra = matches.some((action) => action.params.length > 1);
            if (requiresExtra) {
              setSelection({
                type: "chameleon-extra",
                species: "chameleon",
                handIndex: pendingSelection.handIndex,
                actions: matches,
              });
              return;
            }
          }

          sendSelectedAction(matches[0]);
          return;
        }

        if (pendingSelection.type === "chameleon-extra") {
          const matches = pendingSelection.actions.filter((action) => action.params?.[1] === queueIndex);
          if (!matches.length) {
            return;
          }
          sendSelectedAction(matches[0]);
        }
      }

      function sendSelectedAction(action) {
        pendingSelection = null;
        render();
        void sendAction(action);
      }

      function winnerMessage(scores) {
        if (scores[0] === scores[1]) {
          return "Game over · Draw";
        }
        const winner = scores[0] > scores[1] ? 0 : 1;
        const diff = Math.abs(scores[0] - scores[1]);
        const margin = diff === 1 ? "by 1 point" : `by ${diff} points`;
        return `Game over · Player ${winner} wins ${margin}`;
      }

      function updateHint() {
        if (!hintEl) {
          return;
        }

        if (!currentState) {
          hintEl.textContent = "";
          return;
        }

        if (pendingSelection) {
          if (pendingSelection.type === "target") {
            if (pendingSelection.species === "parrot") {
              hintEl.textContent = "Select a card in the queue for the parrot to shoo away.";
              return;
            }
            if (pendingSelection.species === "chameleon") {
              hintEl.textContent = "Choose an animal in the queue for the chameleon to imitate.";
              return;
            }
            hintEl.textContent = "Select a target in the queue.";
            return;
          }

          if (pendingSelection.type === "chameleon-extra") {
            const copyingParrot = pendingSelection.actions[0]?.params?.length > 1;
            hintEl.textContent = copyingParrot
              ? "Pick the card the chameleon's borrowed parrot will shoo away."
              : "Pick the card affected by the copied ability.";
            return;
          }

          if (pendingSelection.type === "kangaroo") {
            hintEl.textContent = "Pick how far the kangaroo should hop.";
            return;
          }
        }

        if (currentState.isTerminal) {
          hintEl.textContent = "Game finished. Start a new game to play again.";
          return;
        }

        hintEl.textContent = `Player ${currentState.activePlayer}: click a card in your hand to play it.`;
      }

      function clearRender() {
        queueEl.innerHTML = "";
        handContainers.forEach((el) => (el.innerHTML = ""));
        handWrappers.forEach((wrapper) => wrapper.classList.remove("hand-active"));
        updatePilePreview(beastyPreview, beastyCount, []);
        updatePilePreview(thatsPreview, thatsCount, []);
        pendingSelection = null;
        updateHint();
      }

      async function sendAction(action) {
        if (!currentState) return;
        addLogEntry(`Player ${currentState.activePlayer} · ${action.label}`);
        await fetch("/api/action", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(action),
        });
        await refreshState();
      }

      function addLogEntry(message) {
        const entry = {
          id: makeId(),
          message,
          timestamp: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
        };
        eventLog = [entry, ...eventLog].slice(0, 30);
        renderLog();
      }

      function renderLog() {
        logList.innerHTML = "";
        if (!eventLog.length) {
          const empty = document.createElement("li");
          empty.className = "log-empty";
          empty.textContent = "No turns yet";
          logList.appendChild(empty);
          return;
        }

        eventLog.forEach((entry) => {
          const item = document.createElement("li");
          item.className = "log-item";
          const time = document.createElement("time");
          time.dateTime = entry.timestamp;
          time.textContent = entry.timestamp;
          const text = document.createElement("span");
          text.textContent = entry.message;
          item.appendChild(time);
          item.appendChild(text);
          logList.appendChild(item);
        });
      }

      function openPileModal(title, cards) {
        modalTitle.textContent = title;
        modalBody.innerHTML = "";
        const nodes = cards.map((card) => createCard(card));
        if (!nodes.length) {
          const empty = document.createElement("div");
          empty.className = "cards-empty";
          empty.textContent = "Pile empty";
          modalBody.appendChild(empty);
        } else {
          nodes.forEach((node) => modalBody.appendChild(node));
        }
        modalEl.classList.add("modal--open");
        modalEl.setAttribute("aria-hidden", "false");
      }

      function closeModal() {
        modalEl.classList.remove("modal--open");
        modalEl.setAttribute("aria-hidden", "true");
      }

      function makeId() {
        if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
          return crypto.randomUUID();
        }
        return `log-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      refreshState();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Beasty Bar</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f3f4f6;
        --surface: #ffffff;
        --surface-soft: #f9fafb;
        --border: #e5e7eb;
        --border-strong: #d1d5db;
        --text: #111827;
        --muted: #6b7280;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      button,
      select,
      input {
        font: inherit;
      }

      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .top {
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        padding: 1.1rem 1.5rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: space-between;
        align-items: flex-start;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .controls button {
        padding: 0.45rem 0.9rem;
        border-radius: 0.6rem;
        border: 1px solid var(--border-strong);
        background: var(--surface-soft);
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease;
      }

      .controls button:hover {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .controls label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .controls select,
      .controls input {
        padding: 0.4rem 0.6rem;
        border-radius: 0.5rem;
        border: 1px solid var(--border-strong);
        background: var(--surface);
        min-width: 140px;
      }

      .status {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-end;
      }

      .status-line {
        font-weight: 600;
      }

      .scoreboard {
        display: flex;
        gap: 0.8rem;
      }

      .score-card {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 120px;
        padding: 0.6rem 0.85rem;
        border-radius: 0.75rem;
        border: 1px solid var(--border-strong);
        background: var(--surface);
        transition: border-color 0.15s ease, box-shadow 0.15s ease;
      }

      .score-card.active {
        border-color: var(--accent);
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.15);
      }

      .score-card.winner {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .score-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        color: var(--muted);
        letter-spacing: 0.05em;
      }

      .score-value {
        font-size: 1.5rem;
        font-weight: 700;
      }

      .score-line {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .main {
        flex: 1;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .board {
        display: grid;
        grid-template-columns: 180px minmax(0, 1fr) 180px;
        gap: 1rem;
        align-items: start;
      }

      .pile {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 0.8rem;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        min-height: 140px;
      }

      .queue-section {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 0.8rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .pile-header,
      .queue-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
      }

      .pile-count {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .pile-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        flex: 1;
        overflow-y: auto;
      }

      .pile-item {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .pile-item strong {
        color: var(--text);
        font-weight: 600;
      }

      .queue-cards {
        display: flex;
        flex-wrap: nowrap;
        gap: 0.75rem;
        min-height: 210px;
        overflow-x: auto;
        padding-bottom: 0.25rem;
      }

      .card {
        border: 1px solid var(--border-strong);
        border-radius: 0.75rem;
        padding: 0.6rem 0.7rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        width: 140px;
        min-height: 210px;
        transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        position: relative;
        overflow: hidden;
      }

      .card.with-art {
        color: #f8fafc;
        border-color: transparent;
      }

      .card.with-art::before,
      .card.with-art::after {
        content: "";
        position: absolute;
        inset: 0;
        z-index: 0;
        pointer-events: none;
      }

      .card.with-art::before {
        background-image: var(--card-art-image);
        background-size: cover;
        background-position: center;
        filter: saturate(1.05);
      }

      .card.with-art::after {
        background: linear-gradient(180deg, rgba(15, 23, 42, 0.2), rgba(15, 23, 42, 0.65));
      }

      .card.with-art > * {
        position: relative;
        z-index: 1;
        text-shadow: 0 1px 4px rgba(15, 23, 42, 0.7);
      }

      .card.highlight {
        border-color: var(--accent);
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.18);
      }

      .card.targetable {
        cursor: pointer;
        border-color: var(--accent);
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.2);
      }

      .card.targetable:hover,
      .card.targetable:focus {
        transform: translateY(-3px);
      }

      .card.selected {
        border-color: var(--accent);
        box-shadow: 0 10px 22px rgba(37, 99, 235, 0.22);
      }

      .card.dimmed {
        opacity: 0.4;
      }

      .card.hidden {
        background: var(--surface-soft);
        border-style: dashed;
      }

      .card.disabled {
        opacity: 0.45;
        pointer-events: none;
      }

      .card-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.85rem;
        color: var(--muted);
        gap: 0.35rem;
      }

      .card-meta span:last-child {
        font-weight: 600;
      }

      .card.with-art .card-meta {
        color: rgba(248, 250, 252, 0.88);
      }

      .card-species {
        font-weight: 600;
        text-transform: capitalize;
      }

      .card-actions {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .card-actions button {
        font: inherit;
        padding: 0.35rem 0.45rem;
        border-radius: 0.5rem;
        border: 1px solid var(--border-strong);
        background: var(--surface-soft);
        cursor: pointer;
        transition: background 0.15s ease, border-color 0.15s ease;
      }

      .card-actions button:hover,
      .card-actions button:focus {
        border-color: var(--accent);
        background: var(--accent-soft);
      }

      .card.with-art .card-actions button {
        background: rgba(15, 23, 42, 0.55);
        border-color: rgba(248, 250, 252, 0.35);
        color: #f8fafc;
      }

      .card.with-art .card-actions button:hover,
      .card.with-art .card-actions button:focus {
        background: rgba(15, 23, 42, 0.7);
        border-color: rgba(248, 250, 252, 0.5);
      }

      .hands {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .hand {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 0.8rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .hand.active {
        border-color: var(--accent);
        box-shadow: 0 10px 22px rgba(37, 99, 235, 0.15);
      }

      .hand.hidden {
        opacity: 0.6;
      }

      .hand-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: var(--muted);
      }

      .hand-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        min-height: 100px;
      }

      .cards-empty {
        font-size: 0.9rem;
        color: var(--muted);
        background: var(--surface-soft);
        border: 1px dashed var(--border-strong);
        border-radius: 0.6rem;
        padding: 0.6rem 0.8rem;
      }

      .hint {
        margin: 0;
        padding: 0.9rem 1.5rem;
        border-top: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        font-size: 0.9rem;
      }

      @media (max-width: 900px) {
        .board {
          grid-template-columns: 1fr;
        }

        .status {
          align-items: flex-start;
        }
      }

      @media (max-width: 600px) {
        .top {
          padding-inline: 1rem;
        }

        .main {
          padding-inline: 1rem;
        }

        .hint {
          padding-inline: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="top">
        <div class="controls">
          <button id="new-game" type="button">New Game</button>
          <label>
            Seed (optional)
            <input id="seed-input" type="number" placeholder="Random" />
          </label>
          <label>
            You play as
            <select id="human-player-select">
              <option value="0">Player 0 (Blue)</option>
              <option value="1">Player 1 (Orange)</option>
            </select>
          </label>
          <label>
            Starting player
            <select id="starting-player-select">
              <option value="0">Player 0</option>
              <option value="1">Player 1</option>
            </select>
          </label>
        </div>
        <div class="status">
          <div id="status" class="status-line">Loading…</div>
          <div class="scoreboard">
            <div class="score-card" data-player="0">
              <span id="score-label-0" class="score-label">Player 0</span>
              <span id="score-player-0" class="score-value">0</span>
            </div>
            <div class="score-card" data-player="1">
              <span id="score-label-1" class="score-label">Player 1</span>
              <span id="score-player-1" class="score-value">0</span>
            </div>
          </div>
          <div id="score" class="score-line"></div>
        </div>
      </header>
      <main class="main">
        <section class="board">
          <div class="pile" data-pile="beastyBar">
            <div class="pile-header">
              <span>Heaven's Gate</span>
              <span id="beasty-count" class="pile-count">0</span>
            </div>
            <ul id="beasty-preview" class="pile-list"></ul>
          </div>
          <div class="queue-section">
            <div class="queue-header">
              <span>Queue</span>
            </div>
            <div id="queue" class="queue-cards"></div>
          </div>
          <div class="pile" data-pile="thatsIt">
            <div class="pile-header">
              <span>That's It</span>
              <span id="thats-count" class="pile-count">0</span>
            </div>
            <ul id="thats-preview" class="pile-list"></ul>
          </div>
        </section>
        <section class="hands">
          <div id="player-0" class="hand">
            <div class="hand-header">
              <span class="hand-title">Player 0</span>
            </div>
            <div id="hand-0" class="hand-cards"></div>
          </div>
          <div id="player-1" class="hand">
            <div class="hand-header">
              <span class="hand-title">Player 1</span>
            </div>
            <div id="hand-1" class="hand-cards"></div>
          </div>
        </section>
      </main>
      <footer id="hint" class="hint"></footer>
    </div>
    <script>
      let currentState = null;
      let bootstrapped = false;
      let pendingSelection = null;
      const CARD_ART_BASE_PATH = "/static/cards";
      const CARD_ART_STRENGTHS = Array.from({ length: 12 }, (_, idx) => idx + 1);
      const CARD_ART_AVAILABILITY = new Map([
        [0, new Set(CARD_ART_STRENGTHS)],
        [1, new Set(CARD_ART_STRENGTHS)],
      ]);

      const statusEl = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const scoreCards = [
        document.querySelector('.score-card[data-player="0"]'),
        document.querySelector('.score-card[data-player="1"]'),
      ];
      const scoreLabels = [
        document.getElementById("score-label-0"),
        document.getElementById("score-label-1"),
      ];
      const scoreValues = [
        document.getElementById("score-player-0"),
        document.getElementById("score-player-1"),
      ];
      const queueEl = document.getElementById("queue");
      const handWrappers = [document.getElementById("player-0"), document.getElementById("player-1")];
      const handContainers = [document.getElementById("hand-0"), document.getElementById("hand-1")];
      const handTitles = handWrappers.map((wrapper) => wrapper.querySelector(".hand-title"));
      const hintEl = document.getElementById("hint");

      const beastyPreview = document.getElementById("beasty-preview");
      const beastyCount = document.getElementById("beasty-count");
      const thatsPreview = document.getElementById("thats-preview");
      const thatsCount = document.getElementById("thats-count");

      const newGameBtn = document.getElementById("new-game");
      const seedInput = document.getElementById("seed-input");
      const humanPlayerSelect = document.getElementById("human-player-select");
      const startingPlayerSelect = document.getElementById("starting-player-select");

      newGameBtn.addEventListener("click", () => {
        pendingSelection = null;
        const overrides = {};
        const rawSeed = seedInput.value.trim();
        if (rawSeed !== "") {
          const parsed = Number(rawSeed);
          if (!Number.isNaN(parsed)) {
            overrides.seed = parsed;
          }
        }
        startNewGame(overrides);
      });

      seedInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          newGameBtn.click();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          clearSelection();
        }
      });

      async function startNewGame(overrides = {}) {
        const payload = {
          startingPlayer: Number(startingPlayerSelect.value),
          humanPlayer: Number(humanPlayerSelect.value),
        };
        if (overrides && typeof overrides === "object") {
          Object.assign(payload, overrides);
        }
        if (payload.seed === undefined || Number.isNaN(payload.seed)) {
          delete payload.seed;
        }

        const response = await fetch("/api/new-game", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          let message = "Failed to start new game";
          try {
            const data = await response.json();
            if (data?.detail) {
              message = data.detail;
            }
          } catch (error) {
            // ignore parsing issues
          }
          hintEl.textContent = message;
          return;
        }

        bootstrapped = true;
        await refreshState();
      }

      async function refreshState() {
        try {
          const response = await fetch("/api/state");
          if (response.ok) {
            currentState = await response.json();
            render();
            return;
          }
        } catch (error) {
          // fall through to boot logic
        }

        if (!bootstrapped) {
          await startNewGame();
          return;
        }

        currentState = null;
        render();
      }

      function render() {
        if (!currentState) {
          statusEl.textContent = "Create a game to begin.";
          scoreEl.textContent = "";
          scoreValues.forEach((el) => {
            el.textContent = "0";
          });
          scoreCards.forEach((card) => {
            card.classList.remove("active", "winner");
          });
          updatePlayerNames();
          updatePile(beastyPreview, beastyCount, []);
          updatePile(thatsPreview, thatsCount, []);
          renderNodes(queueEl, [], { emptyText: "Queue empty" });
          handWrappers.forEach((wrapper) => {
            wrapper.classList.remove("active", "hidden");
          });
          handContainers.forEach((container) => {
            renderNodes(container, [], { emptyText: "No cards" });
          });
          updateHint();
          return;
        }

        const {
          turn,
          activePlayer,
          isTerminal,
          score,
          zones,
          queue,
          hands,
          seed,
          legalActions = [],
        } = currentState;

        const runningScore = [0, 0];
        zones.beastyBar.forEach((card) => {
          runningScore[card.owner] += card.points;
        });
        const displayScore = isTerminal && Array.isArray(score) ? score : runningScore;

        const displayedTurn = isTerminal ? turn : turn + 1;
        const activeLabel = playerLabel(activePlayer);
        statusEl.textContent = isTerminal
          ? winnerMessage(displayScore)
          : `Turn ${displayedTurn} · ${activeLabel} to play`;

        updatePlayerNames();

        scoreCards.forEach((cardEl) => {
          cardEl.classList.remove("active", "winner");
        });
        scoreValues.forEach((el, idx) => {
          el.textContent = displayScore[idx];
        });

        if (!isTerminal) {
          scoreCards[activePlayer].classList.add("active");
        } else {
          if (displayScore[0] !== displayScore[1]) {
            const winner = displayScore[0] > displayScore[1] ? 0 : 1;
            scoreCards[winner].classList.add("winner");
          }
        }

        if (isTerminal) {
          scoreEl.textContent = `${playerLabel(0)} ${displayScore[0]} – ${playerLabel(1)} ${displayScore[1]}`;
        } else if (seed) {
          scoreEl.textContent = `Seed ${seed} · ${playerLabel(0)} ${displayScore[0]} – ${playerLabel(1)} ${displayScore[1]}`;
        } else {
          scoreEl.textContent = `${playerLabel(0)} ${displayScore[0]} – ${playerLabel(1)} ${displayScore[1]}`;
        }

        const legalByHand = new Map();
        legalActions.forEach((action) => {
          if (!legalByHand.has(action.handIndex)) {
            legalByHand.set(action.handIndex, []);
          }
          legalByHand.get(action.handIndex).push(action);
        });

        const queueTarget = getQueueTargetState();
        const queueNodes = queue.map((card, queueIndex) => {
          const targetable = queueTarget?.indices.has(queueIndex) ?? false;
          const dimmed = Boolean(queueTarget) && !targetable;
          return createCard(card, {
            queue: true,
            targetable,
            dimmed,
            queueIndex,
            artCard: card,
            onClick: targetable ? () => handleQueueCardClick(queueIndex) : null,
          });
        });
        renderNodes(queueEl, queueNodes, { emptyText: "Queue empty" });

        updatePile(beastyPreview, beastyCount, zones.beastyBar);
        updatePile(thatsPreview, thatsCount, zones.thatsIt);

        hands.forEach((hand, playerIndex) => {
          const wrapper = handWrappers[playerIndex];
          const isActive = playerIndex === activePlayer;
          wrapper.classList.toggle("active", isActive);
          wrapper.classList.remove("hidden");

          const nodes = hand.map((card, handIndex) => {
            const actions = isActive ? legalByHand.get(handIndex) ?? [] : [];
            const isSelected =
              isActive && pendingSelection && pendingSelection.handIndex === handIndex;
            let inlineOptions = null;
            if (isSelected) {
              if (pendingSelection.type === "kangaroo") {
                inlineOptions = pendingSelection.actions.map((action) => ({
                  label: kangarooLabel(action),
                  onSelect: () => sendSelectedAction(action),
                }));
              } else if (
                pendingSelection.type === "chameleon-extra" &&
                pendingSelection.copiedSpecies === "kangaroo"
              ) {
                const options = pendingSelection.actions
                  .filter((action) => action.params.length > 1)
                  .map((action) => ({
                    label: kangarooLabel(action, 1),
                    onSelect: () => sendSelectedAction(action),
                  }));
                inlineOptions = options.length ? options : null;
              }
            }

            return createCard(card, {
              highlight: actions.length > 0 && isActive,
              selected: isSelected,
              handIndex,
              onClick: isActive && actions.length > 0 ? () => handleHandCardClick(card, handIndex, actions) : null,
              inlineOptions,
              disabled: isActive && actions.length === 0,
              artCard: card,
            });
          });

          renderNodes(handContainers[playerIndex], nodes, { emptyText: "No cards in hand" });
        });

        updateHint();
      }

      function updatePlayerNames() {
        scoreLabels.forEach((el, idx) => {
          el.textContent = playerLabel(idx);
        });
        handTitles.forEach((el, idx) => {
          el.textContent = playerLabel(idx);
        });
      }

      function playerLabel(playerIndex) {
        if (currentState && typeof currentState.humanPlayer === "number" && playerIndex === currentState.humanPlayer) {
          return "You";
        }
        return `Player ${playerIndex}`;
      }

      function updatePile(listEl, countEl, cards) {
        listEl.innerHTML = "";
        countEl.textContent = cards.length;
        if (!cards.length) {
          const empty = document.createElement("li");
          empty.className = "pile-item";
          empty.textContent = "Empty";
          listEl.appendChild(empty);
          return;
        }
        const recent = cards.slice(-4).reverse();
        if (cards.length > recent.length) {
          const summary = document.createElement("li");
          summary.className = "pile-item";
          summary.textContent = `+${cards.length - recent.length} more`;
          listEl.appendChild(summary);
        }
        recent.forEach((card) => {
          const item = document.createElement("li");
          item.className = "pile-item";
          item.innerHTML = `<strong>${card.species}</strong> · P${card.owner}`;
          listEl.appendChild(item);
        });
      }

      function renderNodes(container, nodes, options = {}) {
        const { emptyText = "Empty" } = options;
        container.innerHTML = "";
        if (nodes.length) {
          nodes.forEach((node) => container.appendChild(node));
          return;
        }
        const empty = document.createElement("div");
        empty.className = "cards-empty";
        empty.textContent = emptyText;
        container.appendChild(empty);
      }

      function createCard(card, options = {}) {
        const {
          highlight = false,
          queue = false,
          targetable = false,
          dimmed = false,
          selected = false,
          hidden = false,
          inlineOptions = null,
          onClick = null,
          handIndex = null,
          queueIndex = null,
          disabled = false,
          artCard = null,
        } = options;

        const el = document.createElement("div");
        el.className = "card";
        const artSource = artCard ?? card;
        if (queue) {
          el.dataset.queueCard = "true";
        }
        if (highlight) {
          el.classList.add("highlight");
        }
        if (targetable) {
          el.classList.add("targetable");
        }
        if (dimmed) {
          el.classList.add("dimmed");
        }
        if (selected) {
          el.classList.add("selected");
        }
        if (hidden) {
          el.classList.add("hidden");
        }
        if (disabled) {
          el.classList.add("disabled");
        }
        if (handIndex !== null) {
          el.dataset.handIndex = String(handIndex);
        }
        if (queueIndex !== null) {
          el.dataset.queueIndex = String(queueIndex);
        }
        if (onClick) {
          el.tabIndex = 0;
          el.addEventListener("click", (event) => {
            event.stopPropagation();
            onClick(event);
          });
          el.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              onClick(event);
            }
          });
        }

        const artUrl = hidden ? null : getCardArtUrl(artSource);
        if (artUrl) {
          el.classList.add("with-art");
          el.style.setProperty("--card-art-image", `url(${artUrl})`);
        }

        const showOverlay = hidden || !artUrl;
        if (showOverlay) {
          const meta = document.createElement("div");
          meta.className = "card-meta";
          const ownerLabel = typeof artSource?.owner === "number" ? `P${artSource.owner}` : "";
          const formattedPoints = typeof card.points === "number" ? `${card.points >= 0 ? '+' : ''}${card.points}` : card.points;
          meta.innerHTML = `<span>${ownerLabel}</span><span>STR ${card.strength}</span><span>${formattedPoints}</span>`;
          el.appendChild(meta);

          const species = document.createElement("div");
          species.className = "card-species";
          species.textContent = card.species;
          el.appendChild(species);
        }

        if (inlineOptions && inlineOptions.length) {
          const actionsEl = document.createElement("div");
          actionsEl.className = "card-actions";
          inlineOptions.forEach((option) => {
            const button = document.createElement("button");
            button.type = "button";
            button.textContent = option.label;
            button.addEventListener("click", (event) => {
              event.stopPropagation();
              option.onSelect();
            });
            actionsEl.appendChild(button);
          });
          el.appendChild(actionsEl);
        }

        return el;
      }

      function getCardArtUrl(card) {
        if (!card || typeof card.owner !== "number" || typeof card.strength !== "number") {
          return null;
        }
        const owner = card.owner;
        const strength = Math.trunc(card.strength);
        if (!Number.isFinite(strength)) {
          return null;
        }
        const ownerArt = CARD_ART_AVAILABILITY.get(owner);
        if (!ownerArt || !ownerArt.has(strength)) {
          return null;
        }
        return `${CARD_ART_BASE_PATH}/${owner}${strength}.jpg`;
      }

      function getQueueTargetState() {
        if (!pendingSelection) {
          return null;
        }

        if (pendingSelection.type === "target") {
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[0];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices };
        }

        if (pendingSelection.type === "chameleon-extra" && pendingSelection.copiedSpecies === "parrot") {
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[1];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices };
        }

        return null;
      }

      function handleHandCardClick(card, handIndex, actions) {
        if (!actions.length) {
          return;
        }

        if (pendingSelection && pendingSelection.handIndex === handIndex) {
          clearSelection();
          return;
        }

        const species = card.species;
        if (species === "parrot" || species === "chameleon") {
          setSelection({ type: "target", species, handIndex, actions });
          return;
        }

        if (species === "kangaroo") {
          const hopOptions = new Set(
            actions
              .filter((action) => action.params && action.params.length)
              .map((action) => action.params[0])
          );
          if (hopOptions.size > 1) {
            setSelection({ type: "kangaroo", species, handIndex, actions });
            return;
          }
        }

        sendSelectedAction(actions[0]);
      }

      function handleQueueCardClick(queueIndex) {
        if (!pendingSelection) {
          return;
        }

        if (pendingSelection.type === "target") {
          const matches = pendingSelection.actions.filter((action) => action.params?.[0] === queueIndex);
          if (!matches.length) {
            return;
          }

          if (pendingSelection.species === "chameleon") {
            const requiresExtra = matches.some((action) => action.params.length > 1);
            if (requiresExtra) {
              const targetCard = currentState?.zones?.queue?.[queueIndex] ?? null;
              const copiedSpecies = targetCard?.species ?? null;
              setSelection({
                type: "chameleon-extra",
                species: "chameleon",
                copiedSpecies,
                handIndex: pendingSelection.handIndex,
                actions: matches,
              });
              return;
            }
          }

          sendSelectedAction(matches[0]);
          return;
        }

        if (pendingSelection.type === "chameleon-extra" && pendingSelection.copiedSpecies === "parrot") {
          const matches = pendingSelection.actions.filter((action) => action.params?.[1] === queueIndex);
          if (!matches.length) {
            return;
          }
          sendSelectedAction(matches[0]);
        }
      }

      function setSelection(selection) {
        pendingSelection = selection;
        render();
      }

      function clearSelection() {
        if (!pendingSelection) {
          return;
        }
        pendingSelection = null;
        render();
      }

      function sendSelectedAction(action) {
        pendingSelection = null;
        render();
        void sendAction(action);
      }

      async function sendAction(action) {
        if (!currentState) {
          return;
        }
        const response = await fetch("/api/action", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(action),
        });
        if (!response.ok) {
          let message = "Move rejected";
          try {
            const data = await response.json();
            if (data?.detail) {
              message = data.detail;
            }
          } catch (error) {
            // ignore parsing issues
          }
          hintEl.textContent = message;
        }
        await refreshState();
      }

      function kangarooLabel(action, paramIndex = 0) {
        const hop = action.params?.[paramIndex] ?? 0;
        if (hop <= 0) {
          return "Stay put";
        }
        return hop === 1 ? "Hop 1 space" : `Hop ${hop} spaces`;
      }

      function winnerMessage(scores) {
        if (scores[0] === scores[1]) {
          return "Game over · Draw";
        }
        const winner = scores[0] > scores[1] ? 0 : 1;
        const diff = Math.abs(scores[0] - scores[1]);
        const margin = diff === 1 ? "by 1 point" : `by ${diff} points`;
        return `Game over · ${playerLabel(winner)} wins ${margin}`;
      }

      function updateHint() {
        if (!hintEl) {
          return;
        }

        if (!currentState) {
          hintEl.textContent = "";
          return;
        }

        if (pendingSelection) {
          if (pendingSelection.type === "target") {
            if (pendingSelection.species === "parrot") {
              hintEl.textContent = "Select a card in the queue for the parrot to shoo away.";
              return;
            }
            if (pendingSelection.species === "chameleon") {
              hintEl.textContent = "Choose a queue card for the chameleon to imitate.";
              return;
            }
            hintEl.textContent = "Select a target in the queue.";
            return;
          }

          if (pendingSelection.type === "chameleon-extra") {
            if (pendingSelection.copiedSpecies === "parrot") {
              hintEl.textContent = "Pick the card the chameleon's borrowed parrot should remove.";
              return;
            }
            if (pendingSelection.copiedSpecies === "kangaroo") {
              hintEl.textContent = "Choose how far the chameleon's hop should go.";
              return;
            }
            hintEl.textContent = "Complete the copied ability.";
            return;
          }

          if (pendingSelection.type === "kangaroo") {
            hintEl.textContent = "Pick how far the kangaroo should hop.";
            return;
          }
        }

        if (currentState.isTerminal) {
          hintEl.textContent = "Game finished. Start a new game to play again.";
          return;
        }

        const active = currentState.activePlayer;
        const label = playerLabel(active);
        const prefix = label === "You" ? "Your turn" : label;
        hintEl.textContent = `${prefix}: choose a card from your hand.`;
      }

      refreshState();
    </script>
  </body>
</html>

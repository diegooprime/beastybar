<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beasty Bar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-elevated: #334155;
      --border: #475569;
      --border-light: #64748b;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      --accent: #3b82f6;
      --accent-glow: rgba(59, 130, 246, 0.4);
      --success: #22c55e;
      --success-glow: rgba(34, 197, 94, 0.3);
      --danger: #ef4444;
      --danger-glow: rgba(239, 68, 68, 0.3);
      --warning: #f59e0b;
      --p0-color: #3b82f6;
      --p1-color: #f97316;
      --card-width: 100px;
      --card-height: 140px;
      --queue-card-width: 120px;
      --queue-card-height: 168px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      gap: 1rem;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .turn-badge {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: var(--bg-elevated);
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .turn-badge.your-turn {
      background: var(--accent);
      color: white;
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 0 var(--accent-glow); }
      50% { box-shadow: 0 0 20px 4px var(--accent-glow); }
    }

    .turn-badge.ai-turn {
      background: var(--p1-color);
      color: white;
    }

    .turn-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    .header-center {
      display: flex;
      align-items: center;
      gap: 2rem;
    }

    .scoreboard {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background: var(--bg-elevated);
      min-width: 80px;
      transition: all 0.2s;
    }

    .score-item.active {
      transform: scale(1.05);
    }

    .score-item[data-player="0"] { border: 2px solid var(--p0-color); }
    .score-item[data-player="1"] { border: 2px solid var(--p1-color); }
    .score-item[data-player="0"].active { box-shadow: 0 0 20px var(--p0-color); }
    .score-item[data-player="1"].active { box-shadow: 0 0 20px var(--p1-color); }

    .score-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .score-value {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .score-divider {
      font-size: 1.25rem;
      color: var(--text-dim);
      font-weight: 300;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.5rem;
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-ai {
      background: var(--p1-color);
      color: white;
      animation: pulse-ai 1.5s ease-in-out infinite;
    }

    @keyframes pulse-ai {
      0%, 100% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4); }
      50% { box-shadow: 0 0 15px 3px rgba(249, 115, 22, 0.4); }
    }

    .btn-ai:hover {
      background: #ea580c;
    }

    /* Game Area */
    .game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Main Board */
    .board {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 1.5rem;
      overflow: hidden;
    }

    /* Side Piles */
    .side-pile {
      width: 140px;
      background: var(--bg-card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      max-height: 100%;
      flex-shrink: 0;
    }

    .pile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .pile-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pile-title.heaven { color: var(--success); }
    .pile-title.hell { color: var(--danger); }

    .pile-count {
      font-size: 0.875rem;
      font-weight: 700;
      color: var(--text-muted);
    }

    .pile-cards {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .pile-card {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.5rem;
      background: var(--bg-elevated);
      border-radius: 0.375rem;
      font-size: 0.8rem;
    }

    .pile-card-owner {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .pile-card-owner[data-owner="0"] { background: var(--p0-color); }
    .pile-card-owner[data-owner="1"] { background: var(--p1-color); }

    .pile-card-name {
      flex: 1;
      text-transform: capitalize;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pile-card-pts {
      color: var(--text-muted);
      font-weight: 600;
    }

    .pile-empty {
      color: var(--text-dim);
      font-size: 0.8rem;
      text-align: center;
      padding: 1rem 0;
    }

    /* Queue */
    .queue-container {
      flex: 1;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .queue-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .queue {
      display: flex;
      gap: 0.75rem;
      padding: 1rem;
      background: var(--bg-card);
      border-radius: 1rem;
      border: 2px dashed var(--border);
      min-height: calc(var(--queue-card-height) + 2rem);
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .queue.targeting {
      border-color: var(--accent);
      background: rgba(59, 130, 246, 0.1);
    }

    .queue-slot {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border: 2px dashed var(--border);
      border-radius: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 0.75rem;
    }

    .queue-direction {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 700px;
      padding: 0 0.5rem;
    }

    .queue-direction span {
      font-size: 0.75rem;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .arrow {
      font-size: 1rem;
    }

    /* Cards */
    .card {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border-radius: 0.75rem;
      background: var(--bg-elevated);
      border: 2px solid var(--border);
      position: relative;
      overflow: hidden;
      cursor: default;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
    }

    .card.hand-card {
      width: var(--card-width);
      height: var(--card-height);
    }

    .card-art {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      z-index: 0;
    }

    .card-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, transparent 30%, rgba(0,0,0,0.7) 100%);
      z-index: 1;
    }

    .card-content {
      position: relative;
      z-index: 2;
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0.5rem;
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .card-owner-badge {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .card-owner-badge[data-owner="0"] { background: var(--p0-color); }
    .card-owner-badge[data-owner="1"] { background: var(--p1-color); }

    .card-strength {
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 0.7rem;
      font-weight: 700;
      padding: 0.15rem 0.4rem;
      border-radius: 0.25rem;
    }

    .card-bottom {
      margin-top: auto;
      text-align: center;
    }

    .card-species {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: capitalize;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .card-points {
      font-size: 0.65rem;
      color: rgba(255,255,255,0.8);
    }

    /* Card States */
    .card.playable {
      cursor: pointer;
      border-color: var(--accent);
      box-shadow: 0 0 0 0 var(--accent-glow);
    }

    .card.playable:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 8px 25px var(--accent-glow);
    }

    .card.selected {
      border-color: var(--success);
      box-shadow: 0 0 20px var(--success-glow);
      transform: translateY(-8px) scale(1.05);
    }

    .card.targetable {
      cursor: pointer;
      border-color: var(--warning);
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
      animation: target-pulse 1s ease-in-out infinite;
    }

    @keyframes target-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 0 25px rgba(245, 158, 11, 0.5); }
    }

    .card.targetable:hover {
      transform: scale(1.05);
    }

    .card.dimmed {
      opacity: 0.3;
      filter: grayscale(0.5);
    }

    .card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .card.no-art {
      background: linear-gradient(135deg, var(--bg-elevated) 0%, var(--bg-card) 100%);
    }

    .card.no-art .card-content {
      justify-content: space-between;
    }

    .card.no-art .card-species {
      font-size: 0.85rem;
    }

    /* Hand */
    .hand-area {
      background: var(--bg-card);
      border-top: 1px solid var(--border);
      padding: 1rem 1.5rem;
      flex-shrink: 0;
    }

    .hand-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .hand-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .hand-cards {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .hand-empty {
      color: var(--text-dim);
      font-size: 0.875rem;
      padding: 2rem;
      text-align: center;
    }

    /* Card Action Buttons */
    .card-actions {
      position: absolute;
      bottom: 0.5rem;
      left: 0.5rem;
      right: 0.5rem;
      z-index: 3;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .card-action-btn {
      padding: 0.3rem 0.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 0.375rem;
      color: white;
      font-size: 0.65rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .card-action-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Hint */
    .hint-bar {
      background: var(--bg-elevated);
      border-top: 1px solid var(--border);
      padding: 0.75rem 1.5rem;
      text-align: center;
      font-size: 0.875rem;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .hint-bar.action-hint {
      background: linear-gradient(90deg, var(--bg-elevated), rgba(59, 130, 246, 0.2), var(--bg-elevated));
      color: var(--text);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      transform: scale(0.9);
      transition: transform 0.2s;
    }

    .modal-overlay.visible .modal {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .modal-field {
      margin-bottom: 1rem;
    }

    .modal-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .modal-input,
    .modal-select {
      width: 100%;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .modal-input:focus,
    .modal-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .modal-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Game Over Overlay */
    .game-over-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }

    .game-over-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .game-over-title {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .game-over-title.win {
      background: linear-gradient(135deg, var(--success), #4ade80);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over-title.lose {
      color: var(--danger);
    }

    .game-over-title.draw {
      color: var(--warning);
    }

    .game-over-score {
      font-size: 1.5rem;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .header {
        flex-wrap: wrap;
        padding: 0.75rem 1rem;
      }

      .header-center {
        order: 3;
        width: 100%;
        justify-content: center;
      }

      .board {
        flex-direction: column;
        padding: 1rem;
      }

      .side-pile {
        width: 100%;
        max-height: 120px;
        flex-direction: row;
        gap: 1rem;
      }

      .pile-header {
        flex-direction: column;
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
        border-right: 1px solid var(--border);
        padding-right: 1rem;
      }

      .pile-cards {
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .queue {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 600px) {
      :root {
        --card-width: 80px;
        --card-height: 112px;
        --queue-card-width: 90px;
        --queue-card-height: 126px;
      }

      .logo {
        font-size: 1rem;
      }

      .score-item {
        min-width: 60px;
        padding: 0.375rem 0.75rem;
      }

      .score-value {
        font-size: 1.25rem;
      }
    }

    /* ===================== AI Battle Mode ===================== */

    /* Battle Mode Container - wraps game area + sidebar */
    .battle-wrapper {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .battle-wrapper.active {
      display: flex;
    }

    /* Hide normal game area when in battle mode */
    body.battle-mode .game-area,
    body.battle-mode .hand-area,
    body.battle-mode .hint-bar {
      display: none;
    }

    body.battle-mode .battle-wrapper {
      display: flex;
    }

    /* Battle main content (board + hands) */
    .battle-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Battle board area */
    .battle-board {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 1rem;
      overflow: hidden;
    }

    /* Dual hand areas */
    .battle-hand {
      background: var(--bg-card);
      border: 1px solid var(--border);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .battle-hand-top {
      border-radius: 0 0 0.75rem 0.75rem;
      border-top: 2px solid var(--p0-color);
    }

    .battle-hand-bottom {
      border-radius: 0.75rem 0.75rem 0 0;
      border-bottom: 2px solid var(--p1-color);
    }

    .battle-hand-label {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
      padding: 0.5rem 0;
    }

    .battle-hand-top .battle-hand-label { color: var(--p0-color); }
    .battle-hand-bottom .battle-hand-label { color: var(--p1-color); }

    .battle-hand-cards {
      display: flex;
      gap: 0.5rem;
      min-height: 100px;
    }

    .battle-hand .card {
      width: 80px;
      height: 112px;
    }

    .battle-hand .hand-empty {
      color: var(--text-dim);
      font-size: 0.8rem;
      padding: 1rem 2rem;
    }

    /* Active player highlight in battle mode */
    .battle-hand.active-player {
      box-shadow: 0 0 20px var(--accent-glow);
      border-color: var(--accent);
    }

    /* Battle Scoreboard Sidebar */
    .battle-sidebar {
      width: 280px;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .battle-sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }

    .battle-sidebar-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 0.25rem;
    }

    .battle-sidebar-subtitle {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .battle-scores {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .battle-score-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .battle-score-row:last-child {
      margin-bottom: 0;
    }

    .battle-score-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .battle-score-row[data-player="0"] .battle-score-color { background: var(--p0-color); }
    .battle-score-row[data-player="1"] .battle-score-color { background: var(--p1-color); }

    .battle-score-name {
      flex: 1;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .battle-score-wins {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .battle-score-row[data-player="0"] .battle-score-wins { color: var(--p0-color); }
    .battle-score-row[data-player="1"] .battle-score-wins { color: var(--p1-color); }

    .battle-progress {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .battle-progress-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .battle-progress-bar {
      height: 8px;
      background: var(--bg-elevated);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .battle-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--p0-color), var(--p1-color));
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .battle-progress-text {
      font-size: 0.875rem;
      color: var(--text);
      text-align: center;
    }

    .battle-winrate {
      padding: 1rem;
      flex: 1;
    }

    .battle-winrate-bar {
      display: flex;
      height: 24px;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .battle-winrate-p0 {
      background: var(--p0-color);
      transition: width 0.3s ease;
    }

    .battle-winrate-p1 {
      background: var(--p1-color);
      transition: width 0.3s ease;
    }

    .battle-winrate-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Playback Controls */
    .battle-controls {
      padding: 1rem;
      background: var(--bg-dark);
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .battle-controls-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .battle-play-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: white;
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .battle-play-btn:hover {
      background: #2563eb;
      transform: scale(1.05);
    }

    .battle-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .battle-speed-control {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .battle-speed-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .battle-speed-slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-elevated);
      border-radius: 3px;
      outline: none;
    }

    .battle-speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: transform 0.15s;
    }

    .battle-speed-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .battle-exit-btn {
      padding: 0.5rem 1rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      color: var(--text);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .battle-exit-btn:hover {
      background: var(--border);
    }

    /* Battle Setup Modal */
    .battle-setup-field {
      display: flex;
      gap: 1rem;
    }

    .battle-setup-field .modal-field {
      flex: 1;
    }

    /* Ability highlight effects */
    .card.event-kill {
      animation: event-kill 0.5s ease-out;
    }

    @keyframes event-kill {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--danger-glow); }
    }

    .card.event-move {
      animation: event-move 0.5s ease-out;
    }

    @keyframes event-move {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--warning); }
    }

    .card.event-score {
      animation: event-score 0.5s ease-out;
    }

    @keyframes event-score {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--success-glow); }
    }

    /* Loading overlay for battle computation */
    .battle-loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .battle-loading-overlay.visible {
      display: flex;
    }

    .battle-loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem 3rem;
      background: var(--bg-card);
      border-radius: 1rem;
      border: 1px solid var(--border);
      min-width: 300px;
    }

    .battle-loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .battle-loading-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    .battle-loading-subtitle {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .battle-loading-progress {
      width: 100%;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      overflow: hidden;
    }

    .battle-loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #8b5cf6);
      border-radius: 3px;
      width: 0%;
      animation: loading-pulse 2s ease-in-out infinite;
    }

    @keyframes loading-pulse {
      0%, 100% { width: 20%; margin-left: 0%; }
      50% { width: 60%; margin-left: 40%; }
    }

    .battle-loading-eta {
      font-size: 0.875rem;
      color: var(--accent);
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">Beasty Bar</div>
      <div id="turn-badge" class="turn-badge">
        <span class="turn-dot"></span>
        <span id="turn-text">Loading...</span>
      </div>
    </div>

    <div class="header-center">
      <div class="scoreboard">
        <div class="score-item" data-player="0">
          <span class="score-label" id="score-label-0">You</span>
          <span class="score-value" id="score-0">0</span>
        </div>
        <span class="score-divider">:</span>
        <div class="score-item" data-player="1">
          <span class="score-label" id="score-label-1">AI</span>
          <span class="score-value" id="score-1">0</span>
        </div>
      </div>
    </div>

    <div class="header-right">
      <button id="ai-move-btn" class="btn btn-ai" style="display: none;">
        AI Move
      </button>
      <button id="ai-battle-btn" class="btn btn-secondary">AI Battle</button>
      <button id="new-game-btn" class="btn btn-secondary">New Game</button>
    </div>
  </header>

  <!-- Game Area -->
  <div class="game-area">
    <div class="board">
      <!-- Heaven's Gate (Left) -->
      <div class="side-pile" id="heaven-pile">
        <div class="pile-header">
          <span class="pile-title heaven">Heaven's Gate</span>
          <span class="pile-count" id="heaven-count">0</span>
        </div>
        <div class="pile-cards" id="heaven-cards"></div>
      </div>

      <!-- Queue (Center) -->
      <div class="queue-container">
        <div class="queue-direction">
          <span><span class="arrow">←</span> Heaven's Gate</span>
          <span class="queue-label">Queue</span>
          <span>That's It <span class="arrow">→</span></span>
        </div>
        <div class="queue" id="queue"></div>
      </div>

      <!-- That's It (Right) -->
      <div class="side-pile" id="hell-pile">
        <div class="pile-header">
          <span class="pile-title hell">That's It</span>
          <span class="pile-count" id="hell-count">0</span>
        </div>
        <div class="pile-cards" id="hell-cards"></div>
      </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="game-over-overlay" id="game-over">
      <div class="game-over-title" id="game-over-title">Victory!</div>
      <div class="game-over-score" id="game-over-score">12 - 8</div>
      <button class="btn btn-primary" id="play-again-btn">Play Again</button>
    </div>
  </div>

  <!-- Hand -->
  <div class="hand-area">
    <div class="hand-header">
      <span class="hand-title">Your Hand</span>
    </div>
    <div class="hand-cards" id="hand"></div>
  </div>

  <!-- Hint Bar -->
  <div class="hint-bar" id="hint">Select a card to play</div>

  <!-- Battle Mode Container -->
  <div class="battle-wrapper" id="battle-wrapper">
    <div class="battle-main">
      <!-- Loading Overlay -->
      <div class="battle-loading-overlay" id="battle-loading-overlay">
        <div class="battle-loading-content">
          <div class="battle-loading-spinner"></div>
          <div class="battle-loading-title" id="battle-loading-title">Computing games...</div>
          <div class="battle-loading-subtitle" id="battle-loading-subtitle">This may take a moment</div>
          <div class="battle-loading-progress">
            <div class="battle-loading-progress-bar" id="battle-loading-progress-bar"></div>
          </div>
          <div class="battle-loading-eta" id="battle-loading-eta">Estimated: ~5 seconds</div>
        </div>
      </div>

      <!-- Player 0 Hand (Top) -->
      <div class="battle-hand battle-hand-top" id="battle-hand-0">
        <span class="battle-hand-label" id="battle-hand-label-0">Player 1</span>
        <div class="battle-hand-cards" id="battle-hand-cards-0"></div>
      </div>

      <!-- Battle Board -->
      <div class="battle-board">
        <!-- Heaven's Gate (Left) -->
        <div class="side-pile" id="battle-heaven-pile">
          <div class="pile-header">
            <span class="pile-title heaven">Heaven's Gate</span>
            <span class="pile-count" id="battle-heaven-count">0</span>
          </div>
          <div class="pile-cards" id="battle-heaven-cards"></div>
        </div>

        <!-- Queue (Center) -->
        <div class="queue-container">
          <div class="queue-direction">
            <span><span class="arrow">←</span> Heaven's Gate</span>
            <span class="queue-label">Queue</span>
            <span>That's It <span class="arrow">→</span></span>
          </div>
          <div class="queue" id="battle-queue"></div>
        </div>

        <!-- That's It (Right) -->
        <div class="side-pile" id="battle-hell-pile">
          <div class="pile-header">
            <span class="pile-title hell">That's It</span>
            <span class="pile-count" id="battle-hell-count">0</span>
          </div>
          <div class="pile-cards" id="battle-hell-cards"></div>
        </div>
      </div>

      <!-- Player 1 Hand (Bottom) -->
      <div class="battle-hand battle-hand-bottom" id="battle-hand-1">
        <span class="battle-hand-label" id="battle-hand-label-1">Player 2</span>
        <div class="battle-hand-cards" id="battle-hand-cards-1"></div>
      </div>
    </div>

    <!-- Battle Sidebar -->
    <div class="battle-sidebar">
      <div class="battle-sidebar-header">
        <div class="battle-sidebar-title">AI Battle</div>
        <div class="battle-sidebar-subtitle" id="battle-matchup">Neural vs Heuristic</div>
      </div>

      <div class="battle-scores">
        <div class="battle-score-row" data-player="0">
          <span class="battle-score-color"></span>
          <span class="battle-score-name" id="battle-p0-name">Player 1</span>
          <span class="battle-score-wins" id="battle-p0-wins">0</span>
        </div>
        <div class="battle-score-row" data-player="1">
          <span class="battle-score-color"></span>
          <span class="battle-score-name" id="battle-p1-name">Player 2</span>
          <span class="battle-score-wins" id="battle-p1-wins">0</span>
        </div>
      </div>

      <div class="battle-progress">
        <div class="battle-progress-label">Progress</div>
        <div class="battle-progress-bar">
          <div class="battle-progress-fill" id="battle-progress-fill" style="width: 0%"></div>
        </div>
        <div class="battle-progress-text" id="battle-progress-text">Game 0 / 0</div>
      </div>

      <div class="battle-winrate">
        <div class="battle-progress-label">Win Rate</div>
        <div class="battle-winrate-bar">
          <div class="battle-winrate-p0" id="battle-winrate-p0" style="width: 50%"></div>
          <div class="battle-winrate-p1" id="battle-winrate-p1" style="width: 50%"></div>
        </div>
        <div class="battle-winrate-labels">
          <span id="battle-winrate-p0-pct">50%</span>
          <span id="battle-winrate-p1-pct">50%</span>
        </div>
      </div>

      <div class="battle-controls">
        <div class="battle-controls-row">
          <button class="battle-play-btn" id="battle-play-btn" title="Play/Pause">▶</button>
          <div class="battle-speed-control">
            <span class="battle-speed-label">Speed: <span id="battle-speed-value">200ms</span></span>
            <input type="range" class="battle-speed-slider" id="battle-speed-slider"
                   min="50" max="1000" value="200" step="50">
          </div>
        </div>
        <button class="battle-exit-btn" id="battle-exit-btn">Exit Battle Mode</button>
      </div>
    </div>
  </div>

  <!-- Battle Setup Modal -->
  <div class="modal-overlay" id="battle-modal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-title">AI Battle Setup</div>

      <div class="battle-setup-field">
        <div class="modal-field">
          <label class="modal-label">Player 1 (Blue)</label>
          <select class="modal-select" id="battle-p1-select">
            <option value="heuristic">Heuristic</option>
          </select>
        </div>
        <div class="modal-field">
          <label class="modal-label">Player 2 (Orange)</label>
          <select class="modal-select" id="battle-p2-select">
            <option value="random">Random</option>
          </select>
        </div>
      </div>

      <div class="modal-field">
        <label class="modal-label">Number of Games (1-200)</label>
        <input type="number" class="modal-input" id="battle-games-input"
               value="50" min="1" max="200" placeholder="50">
      </div>

      <div class="modal-field" style="display: flex; align-items: center; gap: 8px;">
        <input type="checkbox" id="battle-viz-mode" style="width: 18px; height: 18px;">
        <label for="battle-viz-mode" class="modal-label" style="margin: 0; cursor: pointer;">
          Also open Neural Visualizer (second window with network activations)
        </label>
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="battle-cancel">Cancel</button>
        <button class="btn btn-primary" id="battle-start">Start Battle</button>
      </div>
    </div>
  </div>

  <!-- Claude Move Modal -->
  <div class="modal-overlay" id="claude-modal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-title">Claude's Turn</div>
      <div class="modal-field">
        <label class="modal-label">Copy this to Claude Code:</label>
        <textarea class="modal-input" id="claude-state" readonly rows="12" style="font-family: monospace; font-size: 0.8rem; resize: vertical;"></textarea>
      </div>
      <div class="modal-field">
        <button class="btn btn-secondary" id="copy-state-btn" style="width: 100%;">Copy to Clipboard</button>
      </div>
      <div class="modal-field">
        <label class="modal-label">Enter Claude's response (action number):</label>
        <input type="text" class="modal-input" id="claude-move-input" placeholder="e.g., 1 or 2">
      </div>
      <div class="modal-actions">
        <button class="btn btn-primary" id="submit-claude-move" style="flex: 1;">Submit Move</button>
      </div>
    </div>
  </div>

  <!-- New Game Modal -->
  <div class="modal-overlay" id="new-game-modal">
    <div class="modal">
      <div class="modal-title">New Game</div>

      <div class="modal-field">
        <label class="modal-label">Opponent</label>
        <select class="modal-select" id="ai-select">
          <option value="ppo_iter434">PPO iter434 (Strongest)</option>
          <option value="heuristic">Heuristic AI</option>
          <option value="mcts">MCTS AI</option>
          <option value="random">Random AI</option>
          <option value="claude">Claude Opus 4.5 (API)</option>
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">You Play As</label>
        <select class="modal-select" id="player-select">
          <option value="0">Player 1 (Blue, goes first)</option>
          <option value="1">Player 2 (Orange)</option>
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">Seed (optional)</label>
        <input type="number" class="modal-input" id="seed-input" placeholder="Random">
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancel-modal">Cancel</button>
        <button class="btn btn-primary" id="start-game">Start Game</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let gameState = null;
    let pendingSelection = null;
    let isFirstLoad = true;
    let aiMoveTimeout = null;

    // Elements
    const turnBadge = document.getElementById('turn-badge');
    const turnText = document.getElementById('turn-text');
    const scoreLabels = [document.getElementById('score-label-0'), document.getElementById('score-label-1')];
    const scoreValues = [document.getElementById('score-0'), document.getElementById('score-1')];
    const scoreItems = document.querySelectorAll('.score-item');
    const aiMoveBtn = document.getElementById('ai-move-btn');
    const newGameBtn = document.getElementById('new-game-btn');
    const queueEl = document.getElementById('queue');
    const handEl = document.getElementById('hand');
    const heavenCards = document.getElementById('heaven-cards');
    const heavenCount = document.getElementById('heaven-count');
    const hellCards = document.getElementById('hell-cards');
    const hellCount = document.getElementById('hell-count');
    const hintEl = document.getElementById('hint');
    const gameOverEl = document.getElementById('game-over');
    const gameOverTitle = document.getElementById('game-over-title');
    const gameOverScore = document.getElementById('game-over-score');
    const playAgainBtn = document.getElementById('play-again-btn');
    const modalOverlay = document.getElementById('new-game-modal');
    const aiSelect = document.getElementById('ai-select');
    const playerSelect = document.getElementById('player-select');
    const seedInput = document.getElementById('seed-input');
    const cancelModalBtn = document.getElementById('cancel-modal');
    const startGameBtn = document.getElementById('start-game');

    // Claude modal elements
    const claudeModal = document.getElementById('claude-modal');
    const claudeStateEl = document.getElementById('claude-state');
    const copyStateBtn = document.getElementById('copy-state-btn');
    const claudeMoveInput = document.getElementById('claude-move-input');
    const submitClaudeMoveBtn = document.getElementById('submit-claude-move');

    // Card Art
    const CARD_ART_PATH = '/static/cards';

    function getCardArtUrl(card) {
      if (!card || typeof card.owner !== 'number' || typeof card.strength !== 'number') return null;
      if (card.species === 'unknown') return null;
      return `${CARD_ART_PATH}/${card.owner}${card.strength}.jpg`;
    }

    // Event Listeners
    newGameBtn.addEventListener('click', showModal);
    playAgainBtn.addEventListener('click', showModal);
    cancelModalBtn.addEventListener('click', hideModal);
    startGameBtn.addEventListener('click', startNewGame);
    aiMoveBtn.addEventListener('click', makeAiMove);

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) hideModal();
    });

    // Claude modal events
    copyStateBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(claudeStateEl.value);
        copyStateBtn.textContent = 'Copied!';
        setTimeout(() => { copyStateBtn.textContent = 'Copy to Clipboard'; }, 2000);
      } catch (err) {
        claudeStateEl.select();
      }
    });

    submitClaudeMoveBtn.addEventListener('click', submitClaudeMove);
    claudeMoveInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') submitClaudeMove();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (modalOverlay.classList.contains('visible')) {
          hideModal();
        } else if (pendingSelection) {
          clearSelection();
        }
      }
    });

    function showModal() {
      modalOverlay.classList.add('visible');
    }

    function hideModal() {
      modalOverlay.classList.remove('visible');
    }

    async function startNewGame() {
      const payload = {
        humanPlayer: parseInt(playerSelect.value),
        startingPlayer: 0,
        aiOpponent: aiSelect.value
      };

      const seed = seedInput.value.trim();
      if (seed && !isNaN(parseInt(seed))) {
        payload.seed = parseInt(seed);
      }

      try {
        const res = await fetch('/api/new-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (res.ok) {
          hideModal();
          await refreshState();
        }
      } catch (err) {
        console.error('Failed to start game:', err);
      }
    }

    async function makeAiMove() {
      // Clear any pending timeout
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      aiMoveBtn.disabled = true;
      aiMoveBtn.textContent = 'AI Moving...';

      try {
        const res = await fetch('/api/ai-move', { method: 'POST' });
        if (res.ok) {
          await refreshState();
        }
      } catch (err) {
        console.error('AI move failed:', err);
        aiMoveBtn.disabled = false;
        aiMoveBtn.textContent = 'AI Move';
      }
    }

    async function showClaudeModal() {
      try {
        const res = await fetch('/api/claude-state');
        if (res.ok) {
          const data = await res.json();
          claudeStateEl.value = data.formatted;
          claudeMoveInput.value = '';
          claudeModal.classList.add('visible');
        }
      } catch (err) {
        console.error('Failed to get Claude state:', err);
      }
    }

    function hideClaudeModal() {
      claudeModal.classList.remove('visible');
    }

    async function submitClaudeMove() {
      const input = claudeMoveInput.value.trim();
      const actionIndex = parseInt(input);

      if (isNaN(actionIndex) || actionIndex < 1) {
        alert('Please enter a valid action number');
        return;
      }

      submitClaudeMoveBtn.disabled = true;
      submitClaudeMoveBtn.textContent = 'Applying...';

      try {
        const res = await fetch('/api/claude-move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ actionIndex })
        });

        if (res.ok) {
          hideClaudeModal();
          await refreshState();
        } else {
          const err = await res.json();
          alert(err.detail || 'Invalid move');
        }
      } catch (err) {
        console.error('Claude move failed:', err);
        alert('Failed to submit move');
      } finally {
        submitClaudeMoveBtn.disabled = false;
        submitClaudeMoveBtn.textContent = 'Submit Move';
      }
    }

    // Claude Bridge - Automated file-based communication
    let claudePollingInterval = null;

    async function startClaudeBridge() {
      // Don't start if already polling
      if (claudePollingInterval) return;

      // Write state to file for Claude Code to read
      try {
        const res = await fetch('/api/claude-bridge/write-state', { method: 'POST' });
        const data = await res.json();

        if (data.written) {
          // Start polling for Claude's response
          claudePollingInterval = setInterval(checkClaudeResponse, 1000);
        }
      } catch (err) {
        console.error('Failed to write Claude state:', err);
      }
    }

    function stopClaudePolling() {
      if (claudePollingInterval) {
        clearInterval(claudePollingInterval);
        claudePollingInterval = null;
      }
    }

    async function checkClaudeResponse() {
      try {
        const res = await fetch('/api/claude-bridge/check-move');
        const data = await res.json();

        if (data.hasMove) {
          stopClaudePolling();

          // Apply Claude's move
          const applyRes = await fetch('/api/claude-bridge/apply-move', { method: 'POST' });
          if (applyRes.ok) {
            await refreshState();
          } else {
            const err = await applyRes.json();
            console.error('Failed to apply Claude move:', err.detail);
          }
        }
      } catch (err) {
        console.error('Error checking Claude response:', err);
      }
    }

    async function refreshState() {
      try {
        const res = await fetch('/api/state');
        if (res.ok) {
          gameState = await res.json();
          render();
        } else {
          // No active game - show new game modal
          gameState = null;
          showModal();
        }
      } catch (err) {
        if (isFirstLoad) showModal();
      }
      isFirstLoad = false;
    }

    function render() {
      if (!gameState) return;

      const { activePlayer, humanPlayer, isTerminal, score, zones, queue, hands, isAiTurn } = gameState;
      const legalActions = gameState.legalActions || [];
      const isYourTurn = activePlayer === humanPlayer;

      // Scores
      const runningScore = [0, 0];
      zones.beastyBar.forEach(c => { runningScore[c.owner] += c.points; });
      const displayScore = isTerminal && score ? score : runningScore;

      const opponentName = gameState.aiOpponent === 'claude' ? 'Claude' : 'AI';
      scoreLabels[humanPlayer].textContent = 'You';
      scoreLabels[1 - humanPlayer].textContent = opponentName;
      scoreValues[0].textContent = displayScore[0];
      scoreValues[1].textContent = displayScore[1];

      scoreItems.forEach(el => el.classList.remove('active'));
      if (!isTerminal) {
        scoreItems[activePlayer].classList.add('active');
      }

      // Turn Badge
      turnBadge.classList.remove('your-turn', 'ai-turn');
      if (isTerminal) {
        turnText.textContent = 'Game Over';
      } else if (isYourTurn) {
        turnBadge.classList.add('your-turn');
        turnText.textContent = 'Your Turn';
      } else {
        turnBadge.classList.add('ai-turn');
        turnText.textContent = gameState.aiOpponent === 'claude' ? 'Claude\'s Turn' : 'AI Turn';
      }

      // AI/Claude turn handling
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      const isClaudeOpponent = gameState.aiOpponent === 'claude';

      if (isAiTurn && !isTerminal) {
        // All AI opponents (including Claude) use the same flow
        aiMoveBtn.style.display = 'flex';
        aiMoveBtn.textContent = isClaudeOpponent ? 'Claude Thinking...' : 'AI Thinking...';
        aiMoveBtn.disabled = true;
        aiMoveBtn.classList.toggle('btn-ai', !isClaudeOpponent);
        aiMoveBtn.classList.toggle('btn-primary', isClaudeOpponent);

        aiMoveTimeout = setTimeout(() => {
          makeAiMove();
        }, isClaudeOpponent ? 500 : 2000);
      } else {
        aiMoveBtn.style.display = 'none';
      }

      // Piles
      renderPile(heavenCards, heavenCount, zones.beastyBar);
      renderPile(hellCards, hellCount, zones.thatsIt);

      // Queue
      renderQueue(queue, legalActions);

      // Hand
      renderHand(hands[humanPlayer], legalActions, isYourTurn && !isTerminal);

      // Hint
      updateHint(isYourTurn, isTerminal);

      // Game Over
      if (isTerminal) {
        showGameOver(displayScore, humanPlayer);
      } else {
        gameOverEl.classList.remove('visible');
      }
    }

    function renderPile(container, countEl, cards) {
      countEl.textContent = cards.length;
      container.innerHTML = '';

      if (!cards.length) {
        container.innerHTML = '<div class="pile-empty">Empty</div>';
        return;
      }

      [...cards].reverse().forEach(card => {
        const el = document.createElement('div');
        el.className = 'pile-card';
        el.innerHTML = `
          <span class="pile-card-owner" data-owner="${card.owner}"></span>
          <span class="pile-card-name">${card.species}</span>
          <span class="pile-card-pts">+${card.points}</span>
        `;
        container.appendChild(el);
      });
    }

    function renderQueue(cards, legalActions) {
      const targeting = pendingSelection && ['target', 'chameleon-extra'].includes(pendingSelection.type);
      queueEl.classList.toggle('targeting', targeting);
      queueEl.innerHTML = '';

      if (!cards.length) {
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.className = 'queue-slot';
          slot.textContent = i + 1;
          queueEl.appendChild(slot);
        }
        return;
      }

      const targetIndices = getTargetableIndices();

      cards.forEach((card, idx) => {
        const isTargetable = targetIndices.has(idx);
        const isDimmed = targeting && !isTargetable;
        const el = createCardElement(card, {
          targetable: isTargetable,
          dimmed: isDimmed,
          onClick: isTargetable ? () => handleQueueClick(idx) : null
        });
        queueEl.appendChild(el);
      });
    }

    function renderHand(cards, legalActions, canPlay) {
      handEl.innerHTML = '';

      if (!cards.length) {
        handEl.innerHTML = '<div class="hand-empty">No cards in hand</div>';
        return;
      }

      const actionsByHand = new Map();
      legalActions.forEach(a => {
        if (!actionsByHand.has(a.handIndex)) actionsByHand.set(a.handIndex, []);
        actionsByHand.get(a.handIndex).push(a);
      });

      cards.forEach((card, idx) => {
        const actions = actionsByHand.get(idx) || [];
        const isPlayable = canPlay && actions.length > 0;

        const isSelected = pendingSelection?.handIndex === idx;

        let inlineOptions = null;
        if (isSelected) {
          if (pendingSelection.type === 'kangaroo') {
            inlineOptions = pendingSelection.actions.map(a => ({
              label: a.params[0] === 0 ? 'Stay' : `Hop ${a.params[0]}`,
              action: a
            }));
          } else if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'kangaroo') {
            inlineOptions = pendingSelection.actions
              .filter(a => a.params.length > 1)
              .map(a => ({
                label: a.params[1] === 0 ? 'Stay' : `Hop ${a.params[1]}`,
                action: a
              }));
          }
        }

        const el = createCardElement(card, {
          isHandCard: true,
          playable: isPlayable && !pendingSelection,
          selected: isSelected,
          disabled: canPlay && !isPlayable && !isSelected,
          onClick: isPlayable ? () => handleHandClick(card, idx, actions) : null,
          inlineOptions
        });
        handEl.appendChild(el);
      });
    }

    function createCardElement(card, opts = {}) {
      const { isHandCard, playable, selected, targetable, dimmed, disabled, onClick, inlineOptions } = opts;

      const el = document.createElement('div');
      el.className = 'card';
      if (isHandCard) el.classList.add('hand-card');
      if (playable) el.classList.add('playable');
      if (selected) el.classList.add('selected');
      if (targetable) el.classList.add('targetable');
      if (dimmed) el.classList.add('dimmed');
      if (disabled) el.classList.add('disabled');

      const artUrl = getCardArtUrl(card);
      if (artUrl) {
        el.innerHTML = `
          <div class="card-art" style="background-image: url(${artUrl})"></div>
          <div class="card-overlay"></div>
        `;
      } else {
        el.classList.add('no-art');
      }

      const content = document.createElement('div');
      content.className = 'card-content';
      content.innerHTML = `
        <div class="card-top">
          <span class="card-owner-badge" data-owner="${card.owner}"></span>
          <span class="card-strength">${card.strength}</span>
        </div>
        <div class="card-bottom">
          <div class="card-species">${card.species}</div>
          <div class="card-points">+${card.points} pts</div>
        </div>
      `;
      el.appendChild(content);

      if (inlineOptions && inlineOptions.length) {
        const actionsEl = document.createElement('div');
        actionsEl.className = 'card-actions';
        inlineOptions.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'card-action-btn';
          btn.textContent = opt.label;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            sendAction(opt.action);
          });
          actionsEl.appendChild(btn);
        });
        el.appendChild(actionsEl);
      }

      if (onClick) {
        el.addEventListener('click', onClick);
      }

      return el;
    }

    function getTargetableIndices() {
      if (!pendingSelection) return new Set();

      if (pendingSelection.type === 'target') {
        return new Set(pendingSelection.actions.map(a => a.params?.[0]).filter(i => i !== undefined));
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        return new Set(pendingSelection.actions.map(a => a.params?.[1]).filter(i => i !== undefined));
      }

      return new Set();
    }

    function handleHandClick(card, idx, actions) {
      if (pendingSelection?.handIndex === idx) {
        clearSelection();
        return;
      }

      const species = card.species;

      if (species === 'parrot' || species === 'chameleon') {
        setSelection({ type: 'target', species, handIndex: idx, actions });
        return;
      }

      if (species === 'kangaroo') {
        const hops = new Set(actions.map(a => a.params?.[0]));
        if (hops.size > 1) {
          setSelection({ type: 'kangaroo', species, handIndex: idx, actions });
          return;
        }
      }

      sendAction(actions[0]);
    }

    function handleQueueClick(queueIdx) {
      if (!pendingSelection) return;

      if (pendingSelection.type === 'target') {
        const matches = pendingSelection.actions.filter(a => a.params?.[0] === queueIdx);
        if (!matches.length) return;

        if (pendingSelection.species === 'chameleon' && matches.some(a => a.params.length > 1)) {
          const targetCard = gameState?.queue?.[queueIdx];
          setSelection({
            type: 'chameleon-extra',
            species: 'chameleon',
            copiedSpecies: targetCard?.species,
            handIndex: pendingSelection.handIndex,
            actions: matches
          });
          return;
        }

        sendAction(matches[0]);
        return;
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        const matches = pendingSelection.actions.filter(a => a.params?.[1] === queueIdx);
        if (matches.length) sendAction(matches[0]);
      }
    }

    function setSelection(sel) {
      pendingSelection = sel;
      render();
    }

    function clearSelection() {
      pendingSelection = null;
      render();
    }

    async function sendAction(action) {
      pendingSelection = null;
      render();

      try {
        const res = await fetch('/api/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(action)
        });
        if (!res.ok) {
          // Game state lost or invalid action
          console.error('Action failed:', res.status);
        }
        await refreshState();
      } catch (err) {
        console.error('Action failed:', err);
        await refreshState();
      }
    }

    function updateHint(isYourTurn, isTerminal) {
      hintEl.classList.remove('action-hint');

      if (isTerminal) {
        hintEl.textContent = 'Game finished. Click "New Game" to play again.';
        return;
      }

      if (!isYourTurn) {
        hintEl.textContent = gameState?.aiOpponent === 'claude'
          ? 'Claude is thinking...'
          : 'AI is thinking...';
        return;
      }

      if (pendingSelection) {
        hintEl.classList.add('action-hint');
        switch (pendingSelection.type) {
          case 'target':
            if (pendingSelection.species === 'parrot') {
              hintEl.textContent = 'Select a card in the queue to remove';
            } else if (pendingSelection.species === 'chameleon') {
              hintEl.textContent = 'Select a card in the queue to copy its ability';
            }
            break;
          case 'chameleon-extra':
            if (pendingSelection.copiedSpecies === 'parrot') {
              hintEl.textContent = 'Select which card the copied parrot should remove';
            } else if (pendingSelection.copiedSpecies === 'kangaroo') {
              hintEl.textContent = 'Choose how far to hop';
            }
            break;
          case 'kangaroo':
            hintEl.textContent = 'Choose how far to hop';
            break;
        }
        return;
      }

      hintEl.textContent = 'Select a card from your hand to play';
    }

    function showGameOver(scores, humanPlayer) {
      gameOverEl.classList.add('visible');

      const humanScore = scores[humanPlayer];
      const aiScore = scores[1 - humanPlayer];

      gameOverTitle.classList.remove('win', 'lose', 'draw');

      if (humanScore > aiScore) {
        gameOverTitle.textContent = 'Victory!';
        gameOverTitle.classList.add('win');
      } else if (humanScore < aiScore) {
        gameOverTitle.textContent = 'Defeat';
        gameOverTitle.classList.add('lose');
      } else {
        gameOverTitle.textContent = 'Draw';
        gameOverTitle.classList.add('draw');
      }

      gameOverScore.textContent = `${humanScore} - ${aiScore}`;
    }

    // ===================== AI Battle Mode =====================

    // Battle state
    let battleData = null;
    let battleState = 'idle'; // idle, loading, playing, paused, complete
    let battleGameIndex = 0;
    let battleTurnIndex = 0;
    let battleWins = [0, 0];
    let battlePlaybackTimer = null;
    let battleSpeed = 200; // ms per turn

    // Battle elements
    const aiBattleBtn = document.getElementById('ai-battle-btn');
    const battleWrapper = document.getElementById('battle-wrapper');
    const battleModal = document.getElementById('battle-modal');
    const battleP1Select = document.getElementById('battle-p1-select');
    const battleP2Select = document.getElementById('battle-p2-select');
    const battleGamesInput = document.getElementById('battle-games-input');
    const battleCancelBtn = document.getElementById('battle-cancel');
    const battleStartBtn = document.getElementById('battle-start');
    const battlePlayBtn = document.getElementById('battle-play-btn');
    const battleSpeedSlider = document.getElementById('battle-speed-slider');
    const battleSpeedValue = document.getElementById('battle-speed-value');
    const battleExitBtn = document.getElementById('battle-exit-btn');

    // Battle display elements
    const battleMatchup = document.getElementById('battle-matchup');
    const battleP0Name = document.getElementById('battle-p0-name');
    const battleP1Name = document.getElementById('battle-p1-name');
    const battleP0Wins = document.getElementById('battle-p0-wins');
    const battleP1Wins = document.getElementById('battle-p1-wins');
    const battleProgressFill = document.getElementById('battle-progress-fill');
    const battleProgressText = document.getElementById('battle-progress-text');
    const battleWinrateP0 = document.getElementById('battle-winrate-p0');
    const battleWinrateP1 = document.getElementById('battle-winrate-p1');
    const battleWinrateP0Pct = document.getElementById('battle-winrate-p0-pct');
    const battleWinrateP1Pct = document.getElementById('battle-winrate-p1-pct');
    const battleHandLabel0 = document.getElementById('battle-hand-label-0');
    const battleHandLabel1 = document.getElementById('battle-hand-label-1');
    const battleHandCards0 = document.getElementById('battle-hand-cards-0');
    const battleHandCards1 = document.getElementById('battle-hand-cards-1');
    const battleHand0 = document.getElementById('battle-hand-0');
    const battleHand1 = document.getElementById('battle-hand-1');
    const battleQueue = document.getElementById('battle-queue');
    const battleHeavenCards = document.getElementById('battle-heaven-cards');
    const battleHeavenCount = document.getElementById('battle-heaven-count');
    const battleHellCards = document.getElementById('battle-hell-cards');
    const battleHellCount = document.getElementById('battle-hell-count');

    // Loading overlay elements
    const battleLoadingOverlay = document.getElementById('battle-loading-overlay');
    const battleLoadingTitle = document.getElementById('battle-loading-title');
    const battleLoadingSubtitle = document.getElementById('battle-loading-subtitle');
    const battleLoadingEta = document.getElementById('battle-loading-eta');

    // ETA estimation based on agent IDs (ms per game)
    // Estimates are conservative (better to overestimate than underestimate)
    function estimateGameTime(agentId1, agentId2) {
      function isNeural(id) {
        return id.includes('ppo') || id.includes('neural') || id.includes('iter');
      }
      const neural1 = isNeural(agentId1);
      const neural2 = isNeural(agentId2);

      // Both neural: ~600ms/game
      if (neural1 && neural2) return 600;
      // One neural: ~600ms/game (neural inference dominates)
      if (neural1 || neural2) return 600;
      // Heuristic vs Heuristic: ~20ms/game
      if (agentId1 === 'heuristic' && agentId2 === 'heuristic') return 20;
      // Heuristic vs Random or Random vs Random: ~10ms/game
      return 10;
    }

    function formatEta(ms) {
      if (ms < 1000) return 'less than 1 second';
      const seconds = Math.ceil(ms / 1000);
      if (seconds < 60) return `~${seconds} second${seconds > 1 ? 's' : ''}`;
      const minutes = Math.ceil(seconds / 60);
      return `~${minutes} minute${minutes > 1 ? 's' : ''}`;
    }

    function showBattleLoading(numGames, agentId1, agentId2, displayName1, displayName2) {
      const msPerGame = estimateGameTime(agentId1, agentId2);
      const totalMs = numGames * msPerGame;

      battleLoadingTitle.textContent = `Computing ${numGames} games...`;
      battleLoadingSubtitle.textContent = `${displayName1} vs ${displayName2}`;
      battleLoadingEta.textContent = `Estimated: ${formatEta(totalMs)}`;
      battleLoadingOverlay.classList.add('visible');
    }

    function hideBattleLoading() {
      battleLoadingOverlay.classList.remove('visible');
    }

    // Load available agents for battle
    async function loadBattleAgents() {
      try {
        const res = await fetch('/api/ai-agents/battle');
        if (res.ok) {
          const agents = await res.json();
          battleP1Select.innerHTML = '';
          battleP2Select.innerHTML = '';
          agents.forEach((agent, idx) => {
            const opt1 = document.createElement('option');
            opt1.value = agent.id;
            opt1.textContent = agent.name;
            battleP1Select.appendChild(opt1);

            const opt2 = document.createElement('option');
            opt2.value = agent.id;
            opt2.textContent = agent.name;
            battleP2Select.appendChild(opt2);
          });
          // Set different defaults
          if (agents.length > 1) {
            battleP2Select.selectedIndex = 1;
          }
        }
      } catch (err) {
        console.error('Failed to load battle agents:', err);
      }
    }

    // Show battle modal
    function showBattleModal() {
      loadBattleAgents();
      battleModal.classList.add('visible');
    }

    function hideBattleModal() {
      battleModal.classList.remove('visible');
    }

    // Enter battle mode
    function enterBattleMode() {
      document.body.classList.add('battle-mode');
      battleWrapper.classList.add('active');
    }

    // Exit battle mode
    function exitBattleMode() {
      stopBattlePlayback();
      document.body.classList.remove('battle-mode');
      battleWrapper.classList.remove('active');
      battleData = null;
      battleState = 'idle';
      battleGameIndex = 0;
      battleTurnIndex = 0;
      battleWins = [0, 0];
    }

    // Start battle
    async function startBattle() {
      const p1Agent = battleP1Select.value;
      const p2Agent = battleP2Select.value;
      const p1Name = battleP1Select.options[battleP1Select.selectedIndex].text;
      const p2Name = battleP2Select.options[battleP2Select.selectedIndex].text;
      const numGames = Math.min(200, Math.max(1, parseInt(battleGamesInput.value) || 50));
      const useVizMode = document.getElementById('battle-viz-mode').checked;

      hideBattleModal();
      enterBattleMode();
      battleState = 'loading';

      // Clear old viz data
      localStorage.removeItem('battleData');
      localStorage.removeItem('battleSync');

      // Show loading overlay with ETA (pass agent IDs for estimation, names for display)
      showBattleLoading(numGames, p1Agent, p2Agent, p1Name, p2Name);

      // Update sidebar to show loading state
      battleMatchup.textContent = `${p1Name} vs ${p2Name}`;
      battleProgressText.textContent = 'Computing...';
      battlePlayBtn.disabled = true;

      try {
        const res = await fetch('/api/ai-battle/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            player1Agent: p1Agent,
            player2Agent: p2Agent,
            numGames: numGames
          })
        });

        if (!res.ok) {
          throw new Error('Battle request failed');
        }

        battleData = await res.json();
        battleState = 'paused';
        battleGameIndex = 0;
        battleTurnIndex = 0;
        battleWins = [0, 0];

        // Hide loading overlay
        hideBattleLoading();

        // If visualizer mode, store data and open visualizer in new window
        if (useVizMode) {
          localStorage.setItem('battleData', JSON.stringify(battleData));
          localStorage.setItem('battleSync', JSON.stringify({
            gameIndex: 0, turnIndex: 0, wins: [0, 0], speed: battleSpeed
          }));
          // Small delay to ensure localStorage write completes before popup reads
          setTimeout(() => {
            window.vizWindow = window.open('/battle-visualizer?sync=true', 'neural-viz',
              'width=900,height=700,menubar=no,toolbar=no,location=no,status=no');
          }, 100);
        }

        // Update UI with agent names
        battleP0Name.textContent = p1Name;
        battleP1Name.textContent = p2Name;
        battleHandLabel0.textContent = p1Name;
        battleHandLabel1.textContent = p2Name;

        // Enable playback
        battlePlayBtn.disabled = false;
        updateBattleUI();
        renderBattleState();

        // Auto-start playback
        startBattlePlayback();

      } catch (err) {
        console.error('Battle failed:', err);
        hideBattleLoading();
        alert('Failed to start battle. Please try again.');
        exitBattleMode();
      }
    }

    // Playback control
    function startBattlePlayback() {
      if (battleState === 'complete' || !battleData) return;
      battleState = 'playing';
      battlePlayBtn.textContent = '⏸';
      scheduleBattleStep();
    }

    function pauseBattlePlayback() {
      battleState = 'paused';
      battlePlayBtn.textContent = '▶';
      if (battlePlaybackTimer) {
        clearTimeout(battlePlaybackTimer);
        battlePlaybackTimer = null;
      }
    }

    function stopBattlePlayback() {
      battleState = 'idle';
      battlePlayBtn.textContent = '▶';
      if (battlePlaybackTimer) {
        clearTimeout(battlePlaybackTimer);
        battlePlaybackTimer = null;
      }
    }

    function toggleBattlePlayback() {
      if (battleState === 'playing') {
        pauseBattlePlayback();
      } else if (battleState === 'paused' || battleState === 'complete') {
        // If complete, restart from beginning
        if (battleState === 'complete') {
          battleGameIndex = 0;
          battleTurnIndex = 0;
          battleWins = [0, 0];
        }
        startBattlePlayback();
      }
    }

    function scheduleBattleStep() {
      if (battleState !== 'playing') return;
      battlePlaybackTimer = setTimeout(() => {
        advanceBattleStep();
      }, battleSpeed);
    }

    function advanceBattleStep() {
      if (!battleData || battleState !== 'playing') return;

      const games = battleData.games;
      if (battleGameIndex >= games.length) {
        battleState = 'complete';
        battlePlayBtn.textContent = '↻';
        return;
      }

      const currentGame = games[battleGameIndex];
      const turns = currentGame.turns;

      // Advance to next turn
      battleTurnIndex++;

      if (battleTurnIndex >= turns.length) {
        // Game complete - update wins and move to next game
        if (currentGame.winner >= 0) {
          battleWins[currentGame.winner]++;
        }
        battleGameIndex++;
        battleTurnIndex = 0;

        // Check if all games complete
        if (battleGameIndex >= games.length) {
          battleState = 'complete';
          battlePlayBtn.textContent = '↻';
          updateBattleUI();
          renderBattleState();
          return;
        }
      }

      updateBattleUI();
      renderBattleState();
      syncBattleToViz();
      scheduleBattleStep();
    }

    // Sync battle state to visualizer window via sessionStorage
    function syncBattleToViz() {
      if (window.vizWindow && !window.vizWindow.closed) {
        localStorage.setItem('battleSync', JSON.stringify({
          gameIndex: battleGameIndex,
          turnIndex: battleTurnIndex,
          wins: battleWins,
          speed: battleSpeed,
          state: battleState
        }));
      }
    }

    function updateBattleUI() {
      if (!battleData) return;

      const totalGames = battleData.games.length;
      const currentGame = battleGameIndex + 1;
      const progressPct = (battleGameIndex / totalGames) * 100;

      // Update progress
      battleProgressFill.style.width = `${progressPct}%`;
      battleProgressText.textContent = `Game ${Math.min(currentGame, totalGames)} / ${totalGames}`;

      // Update wins
      battleP0Wins.textContent = battleWins[0];
      battleP1Wins.textContent = battleWins[1];

      // Update win rate
      const totalWins = battleWins[0] + battleWins[1];
      if (totalWins > 0) {
        const p0Pct = Math.round((battleWins[0] / totalWins) * 100);
        const p1Pct = 100 - p0Pct;
        battleWinrateP0.style.width = `${p0Pct}%`;
        battleWinrateP1.style.width = `${p1Pct}%`;
        battleWinrateP0Pct.textContent = `${p0Pct}%`;
        battleWinrateP1Pct.textContent = `${p1Pct}%`;
      } else {
        battleWinrateP0.style.width = '50%';
        battleWinrateP1.style.width = '50%';
        battleWinrateP0Pct.textContent = '-';
        battleWinrateP1Pct.textContent = '-';
      }
    }

    function renderBattleState() {
      if (!battleData) return;

      const games = battleData.games;
      if (battleGameIndex >= games.length) {
        // Show final state of last game
        const lastGame = games[games.length - 1];
        const lastTurn = lastGame.turns[lastGame.turns.length - 1];
        renderBattleTurn(lastTurn.state, lastTurn.activePlayer);
        return;
      }

      const currentGame = games[battleGameIndex];
      const turns = currentGame.turns;
      const turnIdx = Math.min(battleTurnIndex, turns.length - 1);
      const turn = turns[turnIdx];

      renderBattleTurn(turn.state, turn.activePlayer);
    }

    function renderBattleTurn(state, activePlayer) {
      // Highlight active player hand
      battleHand0.classList.toggle('active-player', activePlayer === 0);
      battleHand1.classList.toggle('active-player', activePlayer === 1);

      // Update header turn badge
      const p1Name = battleP0Name.textContent;
      const p2Name = battleP1Name.textContent;
      turnBadge.classList.remove('your-turn', 'ai-turn');
      if (state.isTerminal) {
        turnBadge.classList.add('ai-turn');
        turnText.textContent = 'Game Over';
      } else {
        turnBadge.classList.add(activePlayer === 0 ? 'your-turn' : 'ai-turn');
        turnText.textContent = activePlayer === 0 ? `${p1Name}'s Turn` : `${p2Name}'s Turn`;
      }

      // Calculate and update current game scores in header
      const gameScores = [0, 0];
      if (state.zones && state.zones.beastyBar) {
        state.zones.beastyBar.forEach(card => {
          gameScores[card.owner] += card.points;
        });
      }
      scoreLabels[0].textContent = p1Name;
      scoreLabels[1].textContent = p2Name;
      scoreValues[0].textContent = gameScores[0];
      scoreValues[1].textContent = gameScores[1];

      // Highlight active player in scoreboard
      scoreItems.forEach(el => el.classList.remove('active'));
      if (!state.isTerminal) {
        scoreItems[activePlayer].classList.add('active');
      }

      // Render hands
      renderBattleHand(battleHandCards0, state.hands[0]);
      renderBattleHand(battleHandCards1, state.hands[1]);

      // Render queue
      renderBattleQueue(state.queue);

      // Render piles
      renderBattlePile(battleHeavenCards, battleHeavenCount, state.zones.beastyBar);
      renderBattlePile(battleHellCards, battleHellCount, state.zones.thatsIt);
    }

    function renderBattleHand(container, cards) {
      container.innerHTML = '';
      if (!cards || !cards.length) {
        container.innerHTML = '<div class="hand-empty">No cards</div>';
        return;
      }
      cards.forEach(card => {
        const el = createCardElement(card, { isHandCard: true });
        container.appendChild(el);
      });
    }

    function renderBattleQueue(cards) {
      battleQueue.innerHTML = '';
      if (!cards || !cards.length) {
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.className = 'queue-slot';
          slot.textContent = i + 1;
          battleQueue.appendChild(slot);
        }
        return;
      }
      cards.forEach(card => {
        const el = createCardElement(card, {});
        battleQueue.appendChild(el);
      });
    }

    function renderBattlePile(container, countEl, cards) {
      countEl.textContent = cards ? cards.length : 0;
      container.innerHTML = '';
      if (!cards || !cards.length) {
        container.innerHTML = '<div class="pile-empty">Empty</div>';
        return;
      }
      [...cards].reverse().forEach(card => {
        const el = document.createElement('div');
        el.className = 'pile-card';
        el.innerHTML = `
          <span class="pile-card-owner" data-owner="${card.owner}"></span>
          <span class="pile-card-name">${card.species}</span>
          <span class="pile-card-pts">+${card.points}</span>
        `;
        container.appendChild(el);
      });
    }

    // Battle event listeners
    aiBattleBtn.addEventListener('click', showBattleModal);
    battleCancelBtn.addEventListener('click', hideBattleModal);
    battleStartBtn.addEventListener('click', startBattle);
    battlePlayBtn.addEventListener('click', toggleBattlePlayback);
    battleExitBtn.addEventListener('click', exitBattleMode);

    battleModal.addEventListener('click', (e) => {
      if (e.target === battleModal) hideBattleModal();
    });

    battleSpeedSlider.addEventListener('input', () => {
      battleSpeed = parseInt(battleSpeedSlider.value);
      battleSpeedValue.textContent = `${battleSpeed}ms`;
    });

    // Init
    refreshState();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beasty Bar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-elevated: #334155;
      --border: #475569;
      --border-light: #64748b;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      --accent: #3b82f6;
      --accent-glow: rgba(59, 130, 246, 0.4);
      --success: #22c55e;
      --success-glow: rgba(34, 197, 94, 0.3);
      --danger: #ef4444;
      --danger-glow: rgba(239, 68, 68, 0.3);
      --warning: #f59e0b;
      --p0-color: #3b82f6;
      --p1-color: #f97316;
      --card-width: 100px;
      --card-height: 140px;
      --queue-card-width: 120px;
      --queue-card-height: 168px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      gap: 1rem;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .turn-badge {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: var(--bg-elevated);
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .turn-badge.your-turn {
      background: var(--accent);
      color: white;
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 0 var(--accent-glow); }
      50% { box-shadow: 0 0 20px 4px var(--accent-glow); }
    }

    .turn-badge.ai-turn {
      background: var(--p1-color);
      color: white;
    }

    .turn-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    .header-center {
      display: flex;
      align-items: center;
      gap: 2rem;
    }

    .scoreboard {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background: var(--bg-elevated);
      min-width: 80px;
      transition: all 0.2s;
    }

    .score-item.active {
      transform: scale(1.05);
    }

    .score-item[data-player="0"] { border: 2px solid var(--p0-color); }
    .score-item[data-player="1"] { border: 2px solid var(--p1-color); }
    .score-item[data-player="0"].active { box-shadow: 0 0 20px var(--p0-color); }
    .score-item[data-player="1"].active { box-shadow: 0 0 20px var(--p1-color); }

    .score-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .score-value {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .score-divider {
      font-size: 1.25rem;
      color: var(--text-dim);
      font-weight: 300;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.5rem;
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-ai {
      background: var(--p1-color);
      color: white;
      animation: pulse-ai 1.5s ease-in-out infinite;
    }

    @keyframes pulse-ai {
      0%, 100% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4); }
      50% { box-shadow: 0 0 15px 3px rgba(249, 115, 22, 0.4); }
    }

    .btn-ai:hover {
      background: #ea580c;
    }

    /* Game Area */
    .game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Main Board */
    .board {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 1.5rem;
      overflow: hidden;
    }

    /* Side Piles */
    .side-pile {
      width: 140px;
      background: var(--bg-card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      max-height: 100%;
      flex-shrink: 0;
    }

    .pile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .pile-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pile-title.heaven { color: var(--success); }
    .pile-title.hell { color: var(--danger); }

    .pile-count {
      font-size: 0.875rem;
      font-weight: 700;
      color: var(--text-muted);
    }

    .pile-cards {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .pile-card {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.5rem;
      background: var(--bg-elevated);
      border-radius: 0.375rem;
      font-size: 0.8rem;
    }

    .pile-card-owner {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .pile-card-owner[data-owner="0"] { background: var(--p0-color); }
    .pile-card-owner[data-owner="1"] { background: var(--p1-color); }

    .pile-card-name {
      flex: 1;
      text-transform: capitalize;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pile-card-pts {
      color: var(--text-muted);
      font-weight: 600;
    }

    .pile-empty {
      color: var(--text-dim);
      font-size: 0.8rem;
      text-align: center;
      padding: 1rem 0;
    }

    /* Queue */
    .queue-container {
      flex: 1;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .queue-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .queue {
      display: flex;
      gap: 0.75rem;
      padding: 1rem;
      background: var(--bg-card);
      border-radius: 1rem;
      border: 2px dashed var(--border);
      min-height: calc(var(--queue-card-height) + 2rem);
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .queue.targeting {
      border-color: var(--accent);
      background: rgba(59, 130, 246, 0.1);
    }

    .queue-slot {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border: 2px dashed var(--border);
      border-radius: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 0.75rem;
    }

    .queue-direction {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 700px;
      padding: 0 0.5rem;
    }

    .queue-direction span {
      font-size: 0.75rem;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .arrow {
      font-size: 1rem;
    }

    /* Cards */
    .card {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border-radius: 0.75rem;
      background: var(--bg-elevated);
      border: 2px solid var(--border);
      position: relative;
      overflow: hidden;
      cursor: default;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
    }

    .card.hand-card {
      width: var(--card-width);
      height: var(--card-height);
    }

    .card-art {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      z-index: 0;
    }

    .card-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, transparent 30%, rgba(0,0,0,0.7) 100%);
      z-index: 1;
    }

    .card-content {
      position: relative;
      z-index: 2;
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0.5rem;
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .card-owner-badge {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .card-owner-badge[data-owner="0"] { background: var(--p0-color); }
    .card-owner-badge[data-owner="1"] { background: var(--p1-color); }

    .card-strength {
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 0.7rem;
      font-weight: 700;
      padding: 0.15rem 0.4rem;
      border-radius: 0.25rem;
    }

    .card-bottom {
      margin-top: auto;
      text-align: center;
    }

    .card-species {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: capitalize;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .card-points {
      font-size: 0.65rem;
      color: rgba(255,255,255,0.8);
    }

    /* Card States */
    .card.playable {
      cursor: pointer;
      border-color: var(--accent);
      box-shadow: 0 0 0 0 var(--accent-glow);
    }

    .card.playable:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 8px 25px var(--accent-glow);
    }

    .card.selected {
      border-color: var(--success);
      box-shadow: 0 0 20px var(--success-glow);
      transform: translateY(-8px) scale(1.05);
    }

    .card.targetable {
      cursor: pointer;
      border-color: var(--warning);
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
      animation: target-pulse 1s ease-in-out infinite;
    }

    @keyframes target-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 0 25px rgba(245, 158, 11, 0.5); }
    }

    .card.targetable:hover {
      transform: scale(1.05);
    }

    .card.dimmed {
      opacity: 0.3;
      filter: grayscale(0.5);
    }

    .card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .card.no-art {
      background: linear-gradient(135deg, var(--bg-elevated) 0%, var(--bg-card) 100%);
    }

    .card.no-art .card-content {
      justify-content: space-between;
    }

    .card.no-art .card-species {
      font-size: 0.85rem;
    }

    /* Hand */
    .hand-area {
      background: var(--bg-card);
      border-top: 1px solid var(--border);
      padding: 1rem 1.5rem;
      flex-shrink: 0;
    }

    .hand-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .hand-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .hand-cards {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .hand-empty {
      color: var(--text-dim);
      font-size: 0.875rem;
      padding: 2rem;
      text-align: center;
    }

    /* Card Action Buttons */
    .card-actions {
      position: absolute;
      bottom: 0.5rem;
      left: 0.5rem;
      right: 0.5rem;
      z-index: 3;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .card-action-btn {
      padding: 0.3rem 0.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 0.375rem;
      color: white;
      font-size: 0.65rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .card-action-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Hint */
    .hint-bar {
      background: var(--bg-elevated);
      border-top: 1px solid var(--border);
      padding: 0.75rem 1.5rem;
      text-align: center;
      font-size: 0.875rem;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .hint-bar.action-hint {
      background: linear-gradient(90deg, var(--bg-elevated), rgba(59, 130, 246, 0.2), var(--bg-elevated));
      color: var(--text);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      transform: scale(0.9);
      transition: transform 0.2s;
    }

    .modal-overlay.visible .modal {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .modal-field {
      margin-bottom: 1rem;
    }

    .modal-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .modal-input,
    .modal-select {
      width: 100%;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .modal-input:focus,
    .modal-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .modal-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Game Over Overlay */
    .game-over-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }

    .game-over-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .game-over-title {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .game-over-title.win {
      background: linear-gradient(135deg, var(--success), #4ade80);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over-title.lose {
      color: var(--danger);
    }

    .game-over-title.draw {
      color: var(--warning);
    }

    .game-over-score {
      font-size: 1.5rem;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .header {
        flex-wrap: wrap;
        padding: 0.75rem 1rem;
      }

      .header-center {
        order: 3;
        width: 100%;
        justify-content: center;
      }

      .board {
        flex-direction: column;
        padding: 1rem;
      }

      .side-pile {
        width: 100%;
        max-height: 120px;
        flex-direction: row;
        gap: 1rem;
      }

      .pile-header {
        flex-direction: column;
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
        border-right: 1px solid var(--border);
        padding-right: 1rem;
      }

      .pile-cards {
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .queue {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 600px) {
      :root {
        --card-width: 80px;
        --card-height: 112px;
        --queue-card-width: 90px;
        --queue-card-height: 126px;
      }

      .logo {
        font-size: 1rem;
      }

      .score-item {
        min-width: 60px;
        padding: 0.375rem 0.75rem;
      }

      .score-value {
        font-size: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">Beasty Bar</div>
      <div id="turn-badge" class="turn-badge">
        <span class="turn-dot"></span>
        <span id="turn-text">Loading...</span>
      </div>
    </div>

    <div class="header-center">
      <div class="scoreboard">
        <div class="score-item" data-player="0">
          <span class="score-label" id="score-label-0">You</span>
          <span class="score-value" id="score-0">0</span>
        </div>
        <span class="score-divider">:</span>
        <div class="score-item" data-player="1">
          <span class="score-label" id="score-label-1">AI</span>
          <span class="score-value" id="score-1">0</span>
        </div>
      </div>
    </div>

    <div class="header-right">
      <button id="ai-move-btn" class="btn btn-ai" style="display: none;">
        AI Move
      </button>
      <button id="new-game-btn" class="btn btn-secondary">New Game</button>
    </div>
  </header>

  <!-- Game Area -->
  <div class="game-area">
    <div class="board">
      <!-- Heaven's Gate (Left) -->
      <div class="side-pile" id="heaven-pile">
        <div class="pile-header">
          <span class="pile-title heaven">Heaven's Gate</span>
          <span class="pile-count" id="heaven-count">0</span>
        </div>
        <div class="pile-cards" id="heaven-cards"></div>
      </div>

      <!-- Queue (Center) -->
      <div class="queue-container">
        <div class="queue-direction">
          <span><span class="arrow">←</span> Heaven's Gate</span>
          <span class="queue-label">Queue</span>
          <span>That's It <span class="arrow">→</span></span>
        </div>
        <div class="queue" id="queue"></div>
      </div>

      <!-- That's It (Right) -->
      <div class="side-pile" id="hell-pile">
        <div class="pile-header">
          <span class="pile-title hell">That's It</span>
          <span class="pile-count" id="hell-count">0</span>
        </div>
        <div class="pile-cards" id="hell-cards"></div>
      </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="game-over-overlay" id="game-over">
      <div class="game-over-title" id="game-over-title">Victory!</div>
      <div class="game-over-score" id="game-over-score">12 - 8</div>
      <button class="btn btn-primary" id="play-again-btn">Play Again</button>
    </div>
  </div>

  <!-- Hand -->
  <div class="hand-area">
    <div class="hand-header">
      <span class="hand-title">Your Hand</span>
    </div>
    <div class="hand-cards" id="hand"></div>
  </div>

  <!-- Hint Bar -->
  <div class="hint-bar" id="hint">Select a card to play</div>

  <!-- New Game Modal -->
  <div class="modal-overlay" id="new-game-modal">
    <div class="modal">
      <div class="modal-title">New Game</div>

      <div class="modal-field">
        <label class="modal-label">AI Opponent</label>
        <select class="modal-select" id="ai-select">
          <option value="heuristic">Heuristic (Recommended)</option>
          <option value="mcts">MCTS (Strongest)</option>
          <option value="random">Random</option>
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">You Play As</label>
        <select class="modal-select" id="player-select">
          <option value="0">Player 1 (Blue, goes first)</option>
          <option value="1">Player 2 (Orange)</option>
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">Seed (optional)</label>
        <input type="number" class="modal-input" id="seed-input" placeholder="Random">
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancel-modal">Cancel</button>
        <button class="btn btn-primary" id="start-game">Start Game</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let gameState = null;
    let pendingSelection = null;
    let isFirstLoad = true;
    let aiMoveTimeout = null;

    // Elements
    const turnBadge = document.getElementById('turn-badge');
    const turnText = document.getElementById('turn-text');
    const scoreLabels = [document.getElementById('score-label-0'), document.getElementById('score-label-1')];
    const scoreValues = [document.getElementById('score-0'), document.getElementById('score-1')];
    const scoreItems = document.querySelectorAll('.score-item');
    const aiMoveBtn = document.getElementById('ai-move-btn');
    const newGameBtn = document.getElementById('new-game-btn');
    const queueEl = document.getElementById('queue');
    const handEl = document.getElementById('hand');
    const heavenCards = document.getElementById('heaven-cards');
    const heavenCount = document.getElementById('heaven-count');
    const hellCards = document.getElementById('hell-cards');
    const hellCount = document.getElementById('hell-count');
    const hintEl = document.getElementById('hint');
    const gameOverEl = document.getElementById('game-over');
    const gameOverTitle = document.getElementById('game-over-title');
    const gameOverScore = document.getElementById('game-over-score');
    const playAgainBtn = document.getElementById('play-again-btn');
    const modalOverlay = document.getElementById('new-game-modal');
    const aiSelect = document.getElementById('ai-select');
    const playerSelect = document.getElementById('player-select');
    const seedInput = document.getElementById('seed-input');
    const cancelModalBtn = document.getElementById('cancel-modal');
    const startGameBtn = document.getElementById('start-game');

    // Card Art
    const CARD_ART_PATH = '/static/cards';

    function getCardArtUrl(card) {
      if (!card || typeof card.owner !== 'number' || typeof card.strength !== 'number') return null;
      if (card.species === 'unknown') return null;
      return `${CARD_ART_PATH}/${card.owner}${card.strength}.jpg`;
    }

    // Event Listeners
    newGameBtn.addEventListener('click', showModal);
    playAgainBtn.addEventListener('click', showModal);
    cancelModalBtn.addEventListener('click', hideModal);
    startGameBtn.addEventListener('click', startNewGame);
    aiMoveBtn.addEventListener('click', makeAiMove);

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) hideModal();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (modalOverlay.classList.contains('visible')) {
          hideModal();
        } else if (pendingSelection) {
          clearSelection();
        }
      }
    });

    function showModal() {
      modalOverlay.classList.add('visible');
    }

    function hideModal() {
      modalOverlay.classList.remove('visible');
    }

    async function startNewGame() {
      const payload = {
        humanPlayer: parseInt(playerSelect.value),
        startingPlayer: 0,
        aiOpponent: aiSelect.value
      };

      const seed = seedInput.value.trim();
      if (seed && !isNaN(parseInt(seed))) {
        payload.seed = parseInt(seed);
      }

      try {
        const res = await fetch('/api/new-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (res.ok) {
          hideModal();
          await refreshState();
        }
      } catch (err) {
        console.error('Failed to start game:', err);
      }
    }

    async function makeAiMove() {
      // Clear any pending timeout
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      aiMoveBtn.disabled = true;
      aiMoveBtn.textContent = 'AI Moving...';

      try {
        const res = await fetch('/api/ai-move', { method: 'POST' });
        if (res.ok) {
          await refreshState();
        }
      } catch (err) {
        console.error('AI move failed:', err);
        aiMoveBtn.disabled = false;
        aiMoveBtn.textContent = 'AI Move';
      }
    }

    async function refreshState() {
      try {
        const res = await fetch('/api/state');
        if (res.ok) {
          gameState = await res.json();
          render();
        } else if (isFirstLoad) {
          showModal();
        }
      } catch (err) {
        if (isFirstLoad) showModal();
      }
      isFirstLoad = false;
    }

    function render() {
      if (!gameState) return;

      const { activePlayer, humanPlayer, isTerminal, score, zones, queue, hands, isAiTurn } = gameState;
      const legalActions = gameState.legalActions || [];
      const isYourTurn = activePlayer === humanPlayer;

      // Scores
      const runningScore = [0, 0];
      zones.beastyBar.forEach(c => { runningScore[c.owner] += c.points; });
      const displayScore = isTerminal && score ? score : runningScore;

      scoreLabels[humanPlayer].textContent = 'You';
      scoreLabels[1 - humanPlayer].textContent = 'AI';
      scoreValues[0].textContent = displayScore[0];
      scoreValues[1].textContent = displayScore[1];

      scoreItems.forEach(el => el.classList.remove('active'));
      if (!isTerminal) {
        scoreItems[activePlayer].classList.add('active');
      }

      // Turn Badge
      turnBadge.classList.remove('your-turn', 'ai-turn');
      if (isTerminal) {
        turnText.textContent = 'Game Over';
      } else if (isYourTurn) {
        turnBadge.classList.add('your-turn');
        turnText.textContent = 'Your Turn';
      } else {
        turnBadge.classList.add('ai-turn');
        turnText.textContent = 'AI Turn';
      }

      // AI auto-move with delay
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      if (isAiTurn && !isTerminal) {
        aiMoveBtn.style.display = 'flex';
        aiMoveBtn.textContent = 'AI Thinking...';
        aiMoveBtn.disabled = true;

        aiMoveTimeout = setTimeout(() => {
          makeAiMove();
        }, 2000);
      } else {
        aiMoveBtn.style.display = 'none';
      }

      // Piles
      renderPile(heavenCards, heavenCount, zones.beastyBar);
      renderPile(hellCards, hellCount, zones.thatsIt);

      // Queue
      renderQueue(queue, legalActions);

      // Hand
      renderHand(hands[humanPlayer], legalActions, isYourTurn && !isTerminal);

      // Hint
      updateHint(isYourTurn, isTerminal);

      // Game Over
      if (isTerminal) {
        showGameOver(displayScore, humanPlayer);
      } else {
        gameOverEl.classList.remove('visible');
      }
    }

    function renderPile(container, countEl, cards) {
      countEl.textContent = cards.length;
      container.innerHTML = '';

      if (!cards.length) {
        container.innerHTML = '<div class="pile-empty">Empty</div>';
        return;
      }

      [...cards].reverse().forEach(card => {
        const el = document.createElement('div');
        el.className = 'pile-card';
        el.innerHTML = `
          <span class="pile-card-owner" data-owner="${card.owner}"></span>
          <span class="pile-card-name">${card.species}</span>
          <span class="pile-card-pts">+${card.points}</span>
        `;
        container.appendChild(el);
      });
    }

    function renderQueue(cards, legalActions) {
      const targeting = pendingSelection && ['target', 'chameleon-extra'].includes(pendingSelection.type);
      queueEl.classList.toggle('targeting', targeting);
      queueEl.innerHTML = '';

      if (!cards.length) {
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.className = 'queue-slot';
          slot.textContent = i + 1;
          queueEl.appendChild(slot);
        }
        return;
      }

      const targetIndices = getTargetableIndices();

      cards.forEach((card, idx) => {
        const isTargetable = targetIndices.has(idx);
        const isDimmed = targeting && !isTargetable;
        const el = createCardElement(card, {
          targetable: isTargetable,
          dimmed: isDimmed,
          onClick: isTargetable ? () => handleQueueClick(idx) : null
        });
        queueEl.appendChild(el);
      });
    }

    function renderHand(cards, legalActions, canPlay) {
      handEl.innerHTML = '';

      if (!cards.length) {
        handEl.innerHTML = '<div class="hand-empty">No cards in hand</div>';
        return;
      }

      const actionsByHand = new Map();
      legalActions.forEach(a => {
        if (!actionsByHand.has(a.handIndex)) actionsByHand.set(a.handIndex, []);
        actionsByHand.get(a.handIndex).push(a);
      });

      cards.forEach((card, idx) => {
        const actions = actionsByHand.get(idx) || [];
        const isPlayable = canPlay && actions.length > 0;

        const isSelected = pendingSelection?.handIndex === idx;

        let inlineOptions = null;
        if (isSelected) {
          if (pendingSelection.type === 'kangaroo') {
            inlineOptions = pendingSelection.actions.map(a => ({
              label: a.params[0] === 0 ? 'Stay' : `Hop ${a.params[0]}`,
              action: a
            }));
          } else if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'kangaroo') {
            inlineOptions = pendingSelection.actions
              .filter(a => a.params.length > 1)
              .map(a => ({
                label: a.params[1] === 0 ? 'Stay' : `Hop ${a.params[1]}`,
                action: a
              }));
          }
        }

        const el = createCardElement(card, {
          isHandCard: true,
          playable: isPlayable && !pendingSelection,
          selected: isSelected,
          disabled: canPlay && !isPlayable && !isSelected,
          onClick: isPlayable ? () => handleHandClick(card, idx, actions) : null,
          inlineOptions
        });
        handEl.appendChild(el);
      });
    }

    function createCardElement(card, opts = {}) {
      const { isHandCard, playable, selected, targetable, dimmed, disabled, onClick, inlineOptions } = opts;

      const el = document.createElement('div');
      el.className = 'card';
      if (isHandCard) el.classList.add('hand-card');
      if (playable) el.classList.add('playable');
      if (selected) el.classList.add('selected');
      if (targetable) el.classList.add('targetable');
      if (dimmed) el.classList.add('dimmed');
      if (disabled) el.classList.add('disabled');

      const artUrl = getCardArtUrl(card);
      if (artUrl) {
        el.innerHTML = `
          <div class="card-art" style="background-image: url(${artUrl})"></div>
          <div class="card-overlay"></div>
        `;
      } else {
        el.classList.add('no-art');
      }

      const content = document.createElement('div');
      content.className = 'card-content';
      content.innerHTML = `
        <div class="card-top">
          <span class="card-owner-badge" data-owner="${card.owner}"></span>
          <span class="card-strength">${card.strength}</span>
        </div>
        <div class="card-bottom">
          <div class="card-species">${card.species}</div>
          <div class="card-points">+${card.points} pts</div>
        </div>
      `;
      el.appendChild(content);

      if (inlineOptions && inlineOptions.length) {
        const actionsEl = document.createElement('div');
        actionsEl.className = 'card-actions';
        inlineOptions.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'card-action-btn';
          btn.textContent = opt.label;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            sendAction(opt.action);
          });
          actionsEl.appendChild(btn);
        });
        el.appendChild(actionsEl);
      }

      if (onClick) {
        el.addEventListener('click', onClick);
      }

      return el;
    }

    function getTargetableIndices() {
      if (!pendingSelection) return new Set();

      if (pendingSelection.type === 'target') {
        return new Set(pendingSelection.actions.map(a => a.params?.[0]).filter(i => i !== undefined));
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        return new Set(pendingSelection.actions.map(a => a.params?.[1]).filter(i => i !== undefined));
      }

      return new Set();
    }

    function handleHandClick(card, idx, actions) {
      if (pendingSelection?.handIndex === idx) {
        clearSelection();
        return;
      }

      const species = card.species;

      if (species === 'parrot' || species === 'chameleon') {
        setSelection({ type: 'target', species, handIndex: idx, actions });
        return;
      }

      if (species === 'kangaroo') {
        const hops = new Set(actions.map(a => a.params?.[0]));
        if (hops.size > 1) {
          setSelection({ type: 'kangaroo', species, handIndex: idx, actions });
          return;
        }
      }

      sendAction(actions[0]);
    }

    function handleQueueClick(queueIdx) {
      if (!pendingSelection) return;

      if (pendingSelection.type === 'target') {
        const matches = pendingSelection.actions.filter(a => a.params?.[0] === queueIdx);
        if (!matches.length) return;

        if (pendingSelection.species === 'chameleon' && matches.some(a => a.params.length > 1)) {
          const targetCard = gameState?.queue?.[queueIdx];
          setSelection({
            type: 'chameleon-extra',
            species: 'chameleon',
            copiedSpecies: targetCard?.species,
            handIndex: pendingSelection.handIndex,
            actions: matches
          });
          return;
        }

        sendAction(matches[0]);
        return;
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        const matches = pendingSelection.actions.filter(a => a.params?.[1] === queueIdx);
        if (matches.length) sendAction(matches[0]);
      }
    }

    function setSelection(sel) {
      pendingSelection = sel;
      render();
    }

    function clearSelection() {
      pendingSelection = null;
      render();
    }

    async function sendAction(action) {
      pendingSelection = null;
      render();

      try {
        await fetch('/api/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(action)
        });
        await refreshState();
      } catch (err) {
        console.error('Action failed:', err);
      }
    }

    function updateHint(isYourTurn, isTerminal) {
      hintEl.classList.remove('action-hint');

      if (isTerminal) {
        hintEl.textContent = 'Game finished. Click "New Game" to play again.';
        return;
      }

      if (!isYourTurn) {
        hintEl.textContent = 'AI is thinking...';
        return;
      }

      if (pendingSelection) {
        hintEl.classList.add('action-hint');
        switch (pendingSelection.type) {
          case 'target':
            if (pendingSelection.species === 'parrot') {
              hintEl.textContent = 'Select a card in the queue to remove';
            } else if (pendingSelection.species === 'chameleon') {
              hintEl.textContent = 'Select a card in the queue to copy its ability';
            }
            break;
          case 'chameleon-extra':
            if (pendingSelection.copiedSpecies === 'parrot') {
              hintEl.textContent = 'Select which card the copied parrot should remove';
            } else if (pendingSelection.copiedSpecies === 'kangaroo') {
              hintEl.textContent = 'Choose how far to hop';
            }
            break;
          case 'kangaroo':
            hintEl.textContent = 'Choose how far to hop';
            break;
        }
        return;
      }

      hintEl.textContent = 'Select a card from your hand to play';
    }

    function showGameOver(scores, humanPlayer) {
      gameOverEl.classList.add('visible');

      const humanScore = scores[humanPlayer];
      const aiScore = scores[1 - humanPlayer];

      gameOverTitle.classList.remove('win', 'lose', 'draw');

      if (humanScore > aiScore) {
        gameOverTitle.textContent = 'Victory!';
        gameOverTitle.classList.add('win');
      } else if (humanScore < aiScore) {
        gameOverTitle.textContent = 'Defeat';
        gameOverTitle.classList.add('lose');
      } else {
        gameOverTitle.textContent = 'Draw';
        gameOverTitle.classList.add('draw');
      }

      gameOverScore.textContent = `${humanScore} - ${aiScore}`;
    }

    // Init
    refreshState();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Beasty Bar Simulator</title>
    <style>
      :root {
        color-scheme: light;
        --surface: #ffffff;
        --surface-muted: #f5f7fa;
        --surface-strong: #111827;
        --border: #d0d7de;
        --text: #111827;
        --subtle-text: #64748b;
        --accent-blue: #2563eb;
        --accent-orange: #f97316;
        --queue-gradient: linear-gradient(90deg, rgba(37, 99, 235, 0.08), rgba(249, 115, 22, 0.08));
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--surface-muted);
        color: var(--text);
        min-height: 100vh;
      }

      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      button {
        font: inherit;
        cursor: pointer;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        padding: 0.45rem 0.95rem;
        transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
      }

      button:hover {
        background: #eef2ff;
        box-shadow: 0 6px 14px rgba(37, 99, 235, 0.15);
      }

      button:focus-visible {
        outline: 3px solid rgba(37, 99, 235, 0.35);
        outline-offset: 2px;
      }

      input[type="number"] {
        font: inherit;
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 0.45rem 0.9rem;
        width: 140px;
        background: var(--surface);
      }

      select {
        font: inherit;
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 0.45rem 0.9rem;
        background: var(--surface);
      }

      #opponent-select {
        min-width: 180px;
      }

      .control-label {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        font-size: 0.85rem;
        color: var(--subtle-text);
      }

      .control-label select {
        min-width: 120px;
      }

      .top-bar {
        position: sticky;
        top: 0;
        z-index: 10;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        padding: 1.25rem 1.75rem 1rem;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.65));
        backdrop-filter: blur(12px);
        border-bottom: 1px solid rgba(209, 213, 219, 0.6);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.65rem;
      }

      .status-block {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.5rem;
        min-width: 260px;
      }

      .turn-indicator {
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .score-line {
        color: var(--subtle-text);
        font-size: 0.95rem;
      }

      .hint {
        margin: 0;
        padding: 0 1.75rem 0.75rem;
        color: var(--subtle-text);
        font-size: 0.9rem;
        min-height: 1.1rem;
      }

      .scoreboard {
        display: flex;
        align-items: center;
        gap: 0.8rem;
      }

      .score-card {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        padding: 0.6rem 0.9rem;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .score-card__name {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--subtle-text);
      }

      .score-card__value {
        font-size: 1.5rem;
        font-weight: 700;
        line-height: 1.1;
      }

      .score-card--leader {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 14px 30px rgba(37, 99, 235, 0.18);
      }

      .score-card[data-player="1"].score-card--leader {
        border-color: rgba(249, 115, 22, 0.45);
        box-shadow: 0 14px 30px rgba(249, 115, 22, 0.18);
      }

      .score-card--trailing {
        opacity: 0.75;
      }

      .score-card--tied {
        border-style: dashed;
      }

      .score-card--active {
        border-color: rgba(37, 99, 235, 0.45);
        box-shadow: 0 12px 22px rgba(37, 99, 235, 0.16);
      }

      .score-card[data-player="1"].score-card--active {
        border-color: rgba(249, 115, 22, 0.45);
        box-shadow: 0 12px 22px rgba(249, 115, 22, 0.16);
      }

      .score-card--winner {
        border-width: 2px;
        transform: translateY(-4px);
        background: rgba(37, 99, 235, 0.12);
        box-shadow: 0 18px 34px rgba(37, 99, 235, 0.28);
      }

      .score-card[data-player="1"].score-card--winner {
        background: rgba(249, 115, 22, 0.12);
        box-shadow: 0 18px 34px rgba(249, 115, 22, 0.28);
      }

      .main {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        align-items: stretch;
        justify-content: center;
        gap: 1.5rem;
        padding: 1.5rem 1.75rem 2.25rem;
      }

      .board {
        flex: 1 1 640px;
        display: grid;
        grid-template-columns: 220px minmax(0, 1fr) 220px;
        gap: 1.5rem;
        align-items: stretch;
      }

      .pile {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 0.65rem;
        padding: 1.2rem 1rem;
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: var(--surface);
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
        min-height: 260px;
        overflow: hidden;
      }

      .pile:hover {
        transform: translateY(-3px);
        box-shadow: 0 30px 60px rgba(30, 64, 175, 0.25);
      }

      .pile::before {
        content: "";
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0;
        transition: opacity 0.18s ease;
        z-index: 0;
        pointer-events: none;
      }

      .pile.has-art::before {
        opacity: 0.85;
      }

      .pile.has-art > * {
        position: relative;
        z-index: 1;
      }

      .pile.has-art > .pile-label,
      .pile.has-art > .pile-count {
        color: #f8fafc;
        text-shadow: 0 1px 4px rgba(15, 23, 42, 0.65);
      }

      .pile.has-art > .pile-preview {
        background: rgba(15, 23, 42, 0.45);
        border-radius: 14px;
        padding: 0.6rem 0.55rem;
        gap: 0.65rem;
        box-shadow: inset 0 0 0 1px rgba(248, 250, 252, 0.1);
      }

      .pile.has-art .pile-mini-card {
        background: rgba(248, 250, 252, 0.85);
      }

      #gate-pile {
        color: #f8fafc;
      }

      #gate-pile::before {
        background-image: linear-gradient(180deg, rgba(9, 13, 28, 0.25) 0%, rgba(9, 13, 28, 0.75) 100%), url(/static/cards/heaven.jpg);
      }

      #gate-pile.has-art:hover::before {
        opacity: 1;
      }

      #thats-it-pile {
        color: #f8fafc;
      }

      #thats-it-pile::before {
        background-image: linear-gradient(180deg, rgba(24, 6, 6, 0.35) 0%, rgba(15, 5, 5, 0.8) 100%), url(/static/cards/dead.jpg);
      }

      #thats-it-pile.has-art:hover::before {
        opacity: 1;
      }

      .pile-label {
        font-weight: 650;
        font-size: 1.05rem;
        letter-spacing: 0.015em;
        text-transform: uppercase;
      }

      .pile-count {
        font-size: 0.85rem;
        color: var(--subtle-text);
      }

      .pile-preview {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        align-items: stretch;
      }

      .pile-mini-card {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem 0.65rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        background: rgba(248, 250, 252, 0.9);
        box-shadow: 0 6px 12px rgba(15, 23, 42, 0.08);
        font-weight: 600;
        color: var(--subtle-text);
        font-size: 0.85rem;
      }

      .pile-mini-card[data-owner="0"] {
        border-color: rgba(37, 99, 235, 0.55);
        color: rgba(37, 99, 235, 0.85);
      }

      .pile-mini-card[data-owner="1"] {
        border-color: rgba(249, 115, 22, 0.55);
        color: rgba(249, 115, 22, 0.85);
      }

      .pile-mini-card__owner {
        font-size: 0.75rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: inherit;
      }

      .pile-mini-card--summary,
      .pile-mini-card--placeholder {
        justify-content: center;
        color: var(--subtle-text);
        border-style: dashed;
        box-shadow: none;
      }

      .pile-mini-card--summary {
        font-size: 0.8rem;
      }

      .queue-area {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
      }

      .queue-label {
        font-weight: 600;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: var(--subtle-text);
      }

      .queue-track {
        flex: 1;
        min-height: 260px;
        border-radius: 22px;
        border: 1px dashed rgba(148, 163, 184, 0.6);
        background: var(--queue-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        padding: 1.25rem 1rem;
        position: relative;
      }

      .queue-track::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 1.1rem;
        right: 1.1rem;
        height: 4px;
        background: linear-gradient(90deg, rgba(37, 99, 235, 0.25), rgba(249, 115, 22, 0.25));
        border-radius: 999px;
        transform: translateY(-50%);
        pointer-events: none;
      }

      .queue-cards {
        display: flex;
        gap: 1.25rem;
        align-items: flex-start;
        justify-content: center;
        z-index: 1;
      }

      .cards-empty {
        padding: 0.65rem 1rem;
        border-radius: 12px;
        border: 1px dashed rgba(148, 163, 184, 0.65);
        background: rgba(255, 255, 255, 0.64);
        color: var(--subtle-text);
        font-size: 0.9rem;
      }

      .card {
        position: relative;
        width: 148px;
        min-height: 190px;
        border-radius: 18px;
        border: 2px solid rgba(148, 163, 184, 0.45);
        background: var(--surface);
        padding: 0.75rem 0.85rem;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
        overflow: hidden;
      }

      .card.player-0 {
        border-color: rgba(37, 99, 235, 0.6);
        box-shadow: 0 18px 35px rgba(37, 99, 235, 0.15);
      }

      .card.player-1 {
        border-color: rgba(249, 115, 22, 0.6);
        box-shadow: 0 18px 35px rgba(249, 115, 22, 0.15);
      }

      .card.card--with-art {
        color: #f8fafc;
        border-color: rgba(248, 250, 252, 0.65);
        background-image: var(--card-art-gradient), var(--card-art-image);
        background-size: cover, contain;
        background-position: center, center;
        background-repeat: no-repeat, no-repeat;
        position: relative;
        isolation: isolate;
      }

      .card.card--with-art > * {
        position: relative;
        z-index: 1;
        text-shadow: 0 1px 4px rgba(15, 23, 42, 0.6);
      }

      .card.card--with-art .card-top,
      .card.card--with-art .card-species {
        display: none;
      }

      .card--queue {
        min-height: 170px;
        width: 140px;
      }

      .card--subtle {
        background: rgba(248, 250, 252, 0.9);
        border-style: dashed;
        color: var(--subtle-text);
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
      }

      .card--hidden {
        background: repeating-linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.05),
          rgba(15, 23, 42, 0.05) 12px,
          rgba(148, 163, 184, 0.08) 12px,
          rgba(148, 163, 184, 0.08) 24px
        );
        border-style: dashed;
        color: var(--subtle-text);
        pointer-events: none;
        cursor: default;
      }

      .card--hidden .card-top,
      .card--hidden .card-species,
      .card--hidden .card-actions {
        opacity: 0.5;
      }

      .card--hidden .card-points {
        background: rgba(148, 163, 184, 0.75);
        color: #fff;
      }

      .card--playable {
        box-shadow: 0 26px 52px rgba(37, 99, 235, 0.25);
        transform: translateY(-6px);
      }

      .card--playable:hover {
        transform: translateY(-8px);
      }

      .card:hover {
        transform: translateY(-4px);
      }

      .card--clickable {
        cursor: pointer;
      }

      .card--selected {
        border-width: 3px;
        transform: translateY(-10px);
      }

      .card.player-0.card--selected {
        border-color: rgba(37, 99, 235, 0.75);
        box-shadow: 0 30px 58px rgba(37, 99, 235, 0.26);
      }

      .card.player-1.card--selected {
        border-color: rgba(249, 115, 22, 0.75);
        box-shadow: 0 30px 58px rgba(249, 115, 22, 0.26);
      }

      .card--targetable {
        cursor: pointer;
        border-width: 3px;
        transform: translateY(-8px);
        box-shadow: 0 30px 60px rgba(37, 99, 235, 0.25);
      }

      .card.player-1.card--targetable {
        box-shadow: 0 30px 60px rgba(249, 115, 22, 0.25);
        border-color: rgba(249, 115, 22, 0.7);
      }

      .card--targetable:hover {
        transform: translateY(-10px);
      }

      .card--dimmed {
        opacity: 0.35;
        pointer-events: none;
      }

      .card-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
      }

      .card-strength {
        font-size: 2.4rem;
        font-weight: 700;
        line-height: 1;
      }

      .card-points {
        min-width: 48px;
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        background: rgba(17, 24, 39, 0.85);
        color: #f8fafc;
        font-size: 0.85rem;
        text-align: center;
        font-weight: 600;
      }

      .card-points.negative {
        background: rgba(220, 38, 38, 0.85);
      }

      .card-species {
        font-weight: 650;
        font-size: 1.05rem;
        text-transform: capitalize;
      }

      .card-actions {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .card-actions button {
        width: 100%;
        margin: 0;
        border-radius: 12px;
        padding: 0.4rem 0.5rem;
        font-size: 0.85rem;
      }

      .card.card--with-art .card-actions button {
        background: rgba(15, 23, 42, 0.7);
        border-color: rgba(248, 250, 252, 0.35);
        color: #f8fafc;
      }

      .card.card--with-art .card-actions button:hover {
        background: rgba(30, 41, 59, 0.85);
      }

      .hands {
        position: sticky;
        bottom: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1rem;
        padding: 1.25rem 1.75rem 1.75rem;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.85));
        backdrop-filter: blur(18px);
        border-top: 1px solid rgba(209, 213, 219, 0.6);
      }

      .hand {
        background: var(--surface);
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        padding: 1rem 1.1rem;
        box-shadow: 0 15px 32px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }

      .hand-active {
        box-shadow: 0 28px 55px rgba(37, 99, 235, 0.25);
        transform: translateY(-6px);
      }

      .hand.hand-hidden {
        opacity: 0.85;
      }

      .hand-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: var(--subtle-text);
      }

      .hand-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 0.85rem;
      }

      .log {
        flex: 0 0 260px;
        display: flex;
        flex-direction: column;
        background: var(--surface);
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.08);
        max-height: 100%;
        overflow: hidden;
      }

      .log-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.28);
      }

      .log h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: var(--subtle-text);
      }

      .log-actions {
        display: flex;
        gap: 0.5rem;
      }

      .log-toggle {
        padding: 0.35rem 0.8rem;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .log-list {
        list-style: none;
        margin: 0;
        padding: 1.2rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        overflow-y: auto;
      }

      .log-item {
        font-size: 0.9rem;
        color: var(--text);
        line-height: 1.35;
      }

      .log-item time {
        display: block;
        font-size: 0.75rem;
        color: var(--subtle-text);
        margin-bottom: 0.15rem;
      }

      .log-item ul {
        margin: 0.35rem 0 0;
        padding-left: 1.1rem;
        color: var(--subtle-text);
        font-size: 0.8rem;
      }

      .log-item ul li {
        margin: 0.1rem 0;
      }

      .log-empty {
        color: var(--subtle-text);
        font-size: 0.85rem;
      }

      .log-collapsed {
        max-height: 3.25rem;
      }

      .log.log-collapsed .log-list {
        display: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 40;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
      }

      .modal-panel {
        position: relative;
        z-index: 1;
        width: min(720px, 90vw);
        max-height: 80vh;
        background: var(--surface);
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 40px 80px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      }

      .modal-title {
        margin: 0;
        font-size: 1.1rem;
      }

      .modal-body {
        padding: 1.25rem;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .modal-close {
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
      }

      .modal--open {
        display: flex;
      }

      @media (max-width: 1080px) {
        .board {
          grid-template-columns: minmax(0, 1fr);
        }

        .pile,
        .queue-track {
          min-height: 220px;
        }

        .queue-track {
          flex-wrap: wrap;
        }

        .log {
          flex: 1 1 100%;
          min-height: 240px;
          order: 2;
        }
      }

      @media (max-width: 640px) {
        .top-bar {
          padding-inline: 1.1rem;
        }

        .hint {
          margin-inline: 1.1rem;
        }

        .scoreboard {
          width: 100%;
          justify-content: space-between;
        }

        .main {
          padding-inline: 1.1rem;
        }

        .hands {
          padding-inline: 1.1rem;
        }

        .card {
          width: 140px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="top-bar">
        <div class="controls">
          <button id="new-game" type="button">New Game</button>
          <button id="new-seeded" type="button">New Seeded Game</button>
          <input id="seed-input" type="number" placeholder="Seed" />
          <label class="control-label">
            Opponent
            <select id="opponent-select">
              <option value="">Human vs Human</option>
            </select>
          </label>
          <label class="control-label">
            You play as
            <select id="human-player-select">
              <option value="0">Player 0 (Blue)</option>
              <option value="1">Player 1 (Orange)</option>
            </select>
          </label>
          <label class="control-label">
            Starting player
            <select id="starting-player-select">
              <option value="0">Player 0</option>
              <option value="1">Player 1</option>
            </select>
          </label>
        </div>
        <div class="status-block">
          <div id="status" class="turn-indicator">Loading…</div>
          <div class="scoreboard">
            <div id="score-card-0" class="score-card" data-player="0">
              <span class="score-card__name">Player 0</span>
              <span id="score-player-0" class="score-card__value">0</span>
            </div>
            <div id="score-card-1" class="score-card" data-player="1">
              <span class="score-card__name">Player 1</span>
              <span id="score-player-1" class="score-card__value">0</span>
            </div>
          </div>
          <div id="score" class="score-line"></div>
        </div>
      </header>
      <div id="hint" class="hint"></div>
      <div class="main">
        <section class="board">
          <button id="gate-pile" class="pile has-art" type="button" data-pile="beastyBar">
            <div class="pile-label">Heaven's Gate</div>
            <div id="beasty-preview" class="pile-preview"></div>
            <div id="beasty-count" class="pile-count"></div>
          </button>
          <div class="queue-area">
            <div class="queue-label">Line to the Bar</div>
            <div class="queue-track">
              <div id="queue" class="queue-cards"></div>
            </div>
          </div>
          <button id="thats-it-pile" class="pile has-art" type="button" data-pile="thatsIt">
            <div class="pile-label">THAT'S IT</div>
            <div id="thats-preview" class="pile-preview"></div>
            <div id="thats-count" class="pile-count"></div>
          </button>
        </section>
        <aside id="log" class="log">
          <div class="log-header">
            <h2>Turn Log</h2>
            <div class="log-actions">
              <button id="log-copy" type="button" class="log-toggle">Copy Transcript</button>
              <button id="log-toggle" type="button" class="log-toggle" aria-expanded="true">Collapse</button>
            </div>
          </div>
          <ol id="log-list" class="log-list">
            <li class="log-empty">No turns yet</li>
          </ol>
        </aside>
      </div>
      <section class="hands">
        <div id="player-0" class="hand">
          <div class="hand-header">
            <span class="hand-name">Player 0</span>
          </div>
          <div id="hand-0" class="hand-cards"></div>
        </div>
        <div id="player-1" class="hand">
          <div class="hand-header">
            <span class="hand-name">Player 1</span>
          </div>
          <div id="hand-1" class="hand-cards"></div>
        </div>
      </section>
    </div>
    <div id="modal" class="modal" aria-hidden="true">
      <div id="modal-backdrop" class="modal-backdrop"></div>
      <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal-header">
          <h3 id="modal-title" class="modal-title">Pile</h3>
          <button id="modal-close" type="button" class="modal-close" aria-label="Close">×</button>
        </div>
        <div id="modal-body" class="modal-body"></div>
      </div>
    </div>
    <script>
      let currentState = null;
      let bootstrapped = false;
      let pileContents = { beastyBar: [], thatsIt: [] };
      let serverLogEntries = [];
      let localLogEntries = [];
      let pendingSelection = null;
      let availableAgents = [];

      const CARD_ART_BASE_PATH = "/static/cards";
      const CARD_ART_STRENGTHS = Array.from({ length: 12 }, (_, idx) => idx + 1);
      const CARD_ART_AVAILABILITY = new Map([
        [0, new Set(CARD_ART_STRENGTHS)],
        [1, new Set(CARD_ART_STRENGTHS)],
      ]);

      const statusEl = document.getElementById("status");
      const scoreEl = document.getElementById("score");
      const scoreCardEls = [document.getElementById("score-card-0"), document.getElementById("score-card-1")];
      const scoreValueEls = [document.getElementById("score-player-0"), document.getElementById("score-player-1")];
      const scoreNameEls = scoreCardEls.map((card) => card.querySelector(".score-card__name"));
      const queueEl = document.getElementById("queue");
      const handWrappers = [document.getElementById("player-0"), document.getElementById("player-1")];
      const handContainers = [document.getElementById("hand-0"), document.getElementById("hand-1")];
      const handNameEls = handWrappers.map((wrapper) => wrapper.querySelector(".hand-name"));
      const hintEl = document.getElementById("hint");

      const newGameBtn = document.getElementById("new-game");
      const newSeedBtn = document.getElementById("new-seeded");
      const seedInput = document.getElementById("seed-input");
      const opponentSelect = document.getElementById("opponent-select");
      const humanPlayerSelect = document.getElementById("human-player-select");
      const startingPlayerSelect = document.getElementById("starting-player-select");

      const gatePileBtn = document.getElementById("gate-pile");
      const thatsPileBtn = document.getElementById("thats-it-pile");
      const beastyPreview = document.getElementById("beasty-preview");
      const thatsPreview = document.getElementById("thats-preview");
      const beastyCount = document.getElementById("beasty-count");
      const thatsCount = document.getElementById("thats-count");

      const logEl = document.getElementById("log");
      const logToggleBtn = document.getElementById("log-toggle");
      const logCopyBtn = document.getElementById("log-copy");
      const logList = document.getElementById("log-list");

      const modalEl = document.getElementById("modal");
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      const modalClose = document.getElementById("modal-close");
      const modalBackdrop = document.getElementById("modal-backdrop");

      if (logCopyBtn) {
        logCopyBtn.disabled = true;
      }

      newGameBtn.addEventListener("click", () => {
        serverLogEntries = [];
        localLogEntries = [];
        renderLog();
        if (pendingSelection) {
          clearSelection();
        }
        startNewGame();
      });
      newSeedBtn.addEventListener("click", () => {
        const raw = seedInput.value.trim();
        const overrides = {};
        if (raw !== "") {
          const parsed = Number(raw);
          if (!Number.isNaN(parsed)) {
            overrides.seed = parsed;
          }
        }
        serverLogEntries = [];
        localLogEntries = [];
        renderLog();
        if (pendingSelection) {
          clearSelection();
        }
        startNewGame(overrides);
      });

      gatePileBtn.addEventListener("click", () => openPileModal("Heaven's Gate", pileContents.beastyBar));
      thatsPileBtn.addEventListener("click", () => openPileModal("THAT'S IT", pileContents.thatsIt));
      modalClose.addEventListener("click", closeModal);
      modalBackdrop.addEventListener("click", closeModal);
      document.addEventListener("keydown", (event) => {
        if (event.key !== "Escape") {
          return;
        }
        if (modalEl.classList.contains("modal--open")) {
          closeModal();
          return;
        }
        if (pendingSelection) {
          clearSelection();
        }
      });

      logToggleBtn.addEventListener("click", () => {
        const collapsed = logEl.classList.toggle("log-collapsed");
        logToggleBtn.textContent = collapsed ? "Expand" : "Collapse";
        logToggleBtn.setAttribute("aria-expanded", String(!collapsed));
      });

      if (logCopyBtn) {
        logCopyBtn.addEventListener("click", () => {
          const transcript = (currentState?.logText || "").trim();
          if (!transcript) {
            if (hintEl) {
              hintEl.textContent = "No turns to copy yet.";
            }
            return;
          }
          copyTextToClipboard(transcript)
            .then(() => {
              if (hintEl) {
                hintEl.textContent = "Transcript copied to clipboard.";
              }
            })
            .catch(() => {
              if (hintEl) {
                hintEl.textContent = "Clipboard copy failed. Try selecting the log manually.";
              }
            });
        });
      }

      async function startNewGame(overrides = {}) {
        const payload = {
          startingPlayer: Number(startingPlayerSelect.value),
          humanPlayer: Number(humanPlayerSelect.value),
        };
        const opponent = opponentSelect.value;
        if (opponent) {
          payload.opponent = opponent;
        }
        if (overrides && typeof overrides === "object") {
          Object.assign(payload, overrides);
        }
        if (payload.seed === undefined || payload.seed === null || Number.isNaN(payload.seed)) {
          delete payload.seed;
        }

        const response = await fetch("/api/new-game", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          let message = "Failed to start new game";
          try {
            const data = await response.json();
            if (data?.detail) {
              message = data.detail;
            }
          } catch (error) {
            // ignore json parse issues
          }
          hintEl.textContent = message;
          addLocalLogEntry({
            message: `Error · ${message}`,
            timestamp: new Date(),
          });
          return;
        }

        bootstrapped = true;
        await refreshState();
      }

      async function refreshState() {
        const response = await fetch("/api/state");
        if (response.ok) {
          currentState = await response.json();
          render();
        } else if (!bootstrapped) {
          await startNewGame();
        } else {
          currentState = null;
          statusEl.textContent = "Create a game to begin.";
          clearRender();
        }
      }

      function playerLabel(playerIndex) {
        if (currentState && currentState.opponent) {
          const { humanPlayer, agentPlayer, opponent } = currentState;
          if (typeof humanPlayer === "number" && playerIndex === humanPlayer) {
            return "You";
          }
          if (opponent && typeof agentPlayer === "number" && playerIndex === agentPlayer) {
            return opponent;
          }
        }
        return `Player ${playerIndex}`;
      }

      function updatePlayerNames() {
        scoreNameEls.forEach((el, idx) => {
          if (el) {
            el.textContent = playerLabel(idx);
          }
        });
        handNameEls.forEach((el, idx) => {
          if (el) {
            el.textContent = playerLabel(idx);
          }
        });
      }

      function render() {
        if (!currentState) {
          updatePlayerNames();
          updateHint();
          serverLogEntries = [];
          renderLog();
          if (logCopyBtn) {
            logCopyBtn.disabled = true;
          }
          return;
        }
        const { turn, activePlayer, isTerminal, score, zones, queue, hands, seed, log, logText } = currentState;
        serverLogEntries = Array.isArray(log) ? log : [];
        if (logCopyBtn) {
          const transcript = typeof logText === "string" ? logText.trim() : "";
          logCopyBtn.disabled = transcript.length === 0;
        }
        const runningScore = [0, 0];
        zones.beastyBar.forEach((card) => {
          runningScore[card.owner] += card.points;
        });
        const scoreLine = isTerminal && score ? score : runningScore;

        const displayedTurn = isTerminal ? turn : turn + 1;
        const activeLabel = playerLabel(activePlayer);
        statusEl.textContent = isTerminal
          ? winnerMessage(scoreLine)
          : `Turn ${displayedTurn} · ${activeLabel} to play`;

        updatePlayerNames();

        scoreValueEls.forEach((el, idx) => {
          el.textContent = scoreLine[idx];
        });

        scoreCardEls.forEach((cardEl, idx) => {
          cardEl.classList.remove(
            "score-card--leader",
            "score-card--trailing",
            "score-card--tied",
            "score-card--winner",
            "score-card--active",
          );
          if (!isTerminal && idx === activePlayer) {
            cardEl.classList.add("score-card--active");
          }
        });

        const scoreSummary = `${playerLabel(0)} ${scoreLine[0]} – ${playerLabel(1)} ${scoreLine[1]}`;

        if (scoreLine[0] === scoreLine[1]) {
          scoreCardEls.forEach((cardEl) => cardEl.classList.add("score-card--tied"));
        } else {
          const leader = scoreLine[0] > scoreLine[1] ? 0 : 1;
          const trailer = leader === 0 ? 1 : 0;
          if (isTerminal) {
            scoreCardEls[leader].classList.add("score-card--winner");
            scoreCardEls[trailer].classList.add("score-card--trailing");
          } else {
            scoreCardEls[leader].classList.add("score-card--leader");
            scoreCardEls[trailer].classList.add("score-card--trailing");
          }
        }

        if (isTerminal) {
          scoreEl.textContent = `Final score · ${scoreSummary}`;
        } else if (seed) {
          scoreEl.textContent = `Seed ${seed} · ${scoreSummary}`;
        } else {
          scoreEl.textContent = `Running score · ${scoreSummary}`;
        }

        const legalByHand = new Map();
        currentState.legalActions.forEach((action) => {
          if (!legalByHand.has(action.handIndex)) {
            legalByHand.set(action.handIndex, []);
          }
          legalByHand.get(action.handIndex).push(action);
        });

        const queueTarget = getQueueTargetState();
        const queueNodes = queue.map((card, queueIndex) => {
          const tooltip = `Strength ${card.strength} · Points ${card.points} · Player ${card.owner}`;
          const targetable = queueTarget?.indices.has(queueIndex) ?? false;
          const dimmed = Boolean(queueTarget) && !targetable;
          return createCard(card, {
            queue: true,
            tooltip,
            queueIndex,
            targetable,
            dimmed,
            onClick: targetable ? () => handleQueueCardClick(queueIndex) : null,
          });
        });
        renderNodes(queueEl, queueNodes, { emptyText: "Queue empty" });

        pileContents = {
          beastyBar: zones.beastyBar,
          thatsIt: zones.thatsIt,
        };
        updatePilePreview(beastyPreview, beastyCount, zones.beastyBar);
        updatePilePreview(thatsPreview, thatsCount, zones.thatsIt);

        hands.forEach((hand, playerIndex) => {
          const wrapper = handWrappers[playerIndex];
          const isAgentHand =
            Boolean(currentState.opponent) &&
            typeof currentState.agentPlayer === "number" &&
            playerIndex === currentState.agentPlayer;
          wrapper.classList.toggle("hand-active", playerIndex === activePlayer && !isAgentHand);
          wrapper.classList.toggle("hand-hidden", isAgentHand);

          const nodes = hand.map((card, handIndex) => {
            const hidden = isAgentHand;
            const actions = hidden ? [] : playerIndex === activePlayer ? legalByHand.get(handIndex) ?? [] : [];
            const isSelected =
              !hidden &&
              pendingSelection &&
              pendingSelection.handIndex === handIndex &&
              playerIndex === activePlayer;
            let inlineOptions = null;
            if (!hidden && isSelected) {
              if (pendingSelection.type === "kangaroo") {
                inlineOptions = pendingSelection.actions.map((action) => ({
                  label: kangarooLabel(action),
                  onSelect: () => sendSelectedAction(action),
                }));
              } else if (
                pendingSelection.type === "chameleon-extra" &&
                pendingSelection.copiedSpecies === "kangaroo"
              ) {
                const options = pendingSelection.actions
                  .filter((action) => action.params.length > 1)
                  .map((action) => ({
                    label: kangarooLabel(action, 1),
                    onSelect: () => sendSelectedAction(action),
                  }));
                inlineOptions = options.length ? options : null;
              }
            }
            const displayCard = hidden
              ? {
                  owner: card.owner,
                  species: "Hidden",
                  strength: "?",
                  points: "?",
                }
              : card;
            return createCard(displayCard, {
              originalCard: card,
              hidden,
              highlight: !hidden && actions.length > 0 && playerIndex === activePlayer,
              selected: isSelected,
              handIndex,
              onClick:
                !hidden && playerIndex === activePlayer && actions.length > 0
                  ? () => handleHandCardClick(card, handIndex, actions)
                  : null,
              inlineOptions,
            });
          });
          renderNodes(handContainers[playerIndex], nodes, { emptyText: "No cards in hand" });
        });

        updateHint();
        renderLog();
      }

      function getCardArtUrl(card) {
        if (!card || typeof card.owner !== "number" || typeof card.strength !== "number") {
          return null;
        }
        const owner = card.owner;
        const strength = Math.trunc(card.strength);
        if (!Number.isFinite(strength)) {
          return null;
        }
        const ownerArt = CARD_ART_AVAILABILITY.get(owner);
        if (!ownerArt || !ownerArt.has(strength)) {
          return null;
        }
        return `${CARD_ART_BASE_PATH}/${owner}${strength}.jpg`;
      }

      function createCard(card, options = {}) {
        const {
          actions = [],
          subtle = false,
          highlight = false,
          queue = false,
          tooltip = "",
          selected = false,
          targetable = false,
          dimmed = false,
          onClick = null,
          handIndex = null,
          queueIndex = null,
          inlineOptions = null,
          hidden = false,
          originalCard = null,
        } = options;
        const sourceCard = originalCard ?? card;
        const div = document.createElement("div");
        div.className = "card";
        div.classList.add(`player-${sourceCard.owner}`);
        if (queue) div.classList.add("card--queue");
        if (subtle) {
          div.classList.add("card--subtle");
        }
        if (highlight) {
          div.classList.add("card--playable");
        }
        if (selected) {
          div.classList.add("card--selected");
        }
        if (targetable) {
          div.classList.add("card--targetable");
        }
        if (dimmed) {
          div.classList.add("card--dimmed");
        }
        if (hidden) {
          div.classList.add("card--hidden");
        }
        if (tooltip) {
          div.title = tooltip;
        }
        if (handIndex !== null) {
          div.dataset.handIndex = String(handIndex);
        }
        if (queueIndex !== null) {
          div.dataset.queueIndex = String(queueIndex);
        }
        if (onClick) {
          div.classList.add("card--clickable");
          div.setAttribute("role", "button");
          div.tabIndex = 0;
          div.addEventListener("click", (event) => {
            event.stopPropagation();
            onClick(event);
          });
          div.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              onClick(event);
            }
          });
        }

        const artUrl = hidden ? null : getCardArtUrl(sourceCard);
        if (artUrl) {
          div.classList.add("card--with-art");
          div.style.setProperty(
            "--card-art-gradient",
            "linear-gradient(180deg, rgba(9, 13, 28, 0.08) 0%, rgba(9, 13, 28, 0.45) 100%)",
          );
          div.style.setProperty("--card-art-image", `url(${artUrl})`);
        }

        const top = document.createElement("div");
        top.className = "card-top";
        const strength = document.createElement("div");
        strength.className = "card-strength";
        strength.textContent = card.strength;
        const points = document.createElement("span");
        points.className = "card-points";
        if (hidden) {
          points.textContent = "?";
        } else {
          points.textContent = `${sourceCard.points >= 0 ? "+" : ""}${sourceCard.points}`;
          if (sourceCard.points < 0) {
            points.classList.add("negative");
          }
        }
        top.appendChild(strength);
        top.appendChild(points);
        div.appendChild(top);

        const species = document.createElement("div");
        species.className = "card-species";
        species.textContent = card.species;
        div.appendChild(species);

        if (inlineOptions?.length) {
          const actionsEl = document.createElement("div");
          actionsEl.className = "card-actions";
          inlineOptions.forEach((option) => {
            const button = document.createElement("button");
            button.type = "button";
            button.textContent = option.label;
            button.addEventListener("click", (event) => {
              event.stopPropagation();
              option.onSelect();
            });
            actionsEl.appendChild(button);
          });
          div.appendChild(actionsEl);
        }

        return div;
      }

      function renderNodes(container, nodes, options = {}) {
        const { emptyText = "Empty" } = options;
        container.innerHTML = "";
        nodes.forEach((node) => container.appendChild(node));
        if (!nodes.length) {
          const empty = document.createElement("div");
          empty.className = "cards-empty";
          empty.textContent = emptyText;
          container.appendChild(empty);
        }
      }

      function updatePilePreview(previewEl, countEl, cards, options = {}) {
        const { emptyText = "Empty" } = options;
        previewEl.innerHTML = "";
        if (!cards.length) {
          const placeholder = document.createElement("div");
          placeholder.className = "pile-mini-card pile-mini-card--placeholder";
          placeholder.textContent = emptyText;
          previewEl.appendChild(placeholder);
          countEl.textContent = "";
          return;
        }

        const display = cards.slice(-4).reverse();
        const hidden = cards.length - display.length;

        if (hidden > 0) {
          const summary = document.createElement("div");
          summary.className = "pile-mini-card pile-mini-card--summary";
          summary.textContent = `+${hidden} more`;
          previewEl.appendChild(summary);
        }

        display.forEach((card) => {
          const mini = document.createElement("div");
          mini.className = "pile-mini-card";
          mini.dataset.owner = String(card.owner);
          const name = document.createElement("span");
          name.textContent = card.species;
          const owner = document.createElement("span");
          owner.className = "pile-mini-card__owner";
          owner.textContent = `P${card.owner}`;
          mini.appendChild(name);
          mini.appendChild(owner);
          previewEl.appendChild(mini);
        });
        countEl.textContent = `${cards.length} card${cards.length === 1 ? "" : "s"}`;
      }

      function kangarooLabel(action, paramIndex = 0) {
        const hop = action.params?.[paramIndex] ?? 0;
        if (hop <= 0) {
          return "Stay put";
        }
        return hop === 1 ? "Hop 1 space" : `Hop ${hop} spaces`;
      }

      function getQueueTargetState() {
        if (!pendingSelection) {
          return null;
        }

        if (pendingSelection.type === "target") {
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[0];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices, step: "target", species: pendingSelection.species };
        }

        if (pendingSelection.type === "chameleon-extra") {
          if (pendingSelection.copiedSpecies !== "parrot") {
            return null;
          }
          const indices = new Set();
          pendingSelection.actions.forEach((action) => {
            const targetIndex = action.params?.[1];
            if (typeof targetIndex === "number") {
              indices.add(targetIndex);
            }
          });
          return { indices, step: "extra", species: "chameleon" };
        }

        return null;
      }

      function setSelection(selection) {
        pendingSelection = selection;
        render();
      }

      function clearSelection() {
        if (!pendingSelection) {
          return;
        }
        pendingSelection = null;
        render();
      }

      function handleHandCardClick(card, handIndex, actions) {
        if (!actions.length) {
          return;
        }

        if (pendingSelection && pendingSelection.handIndex === handIndex) {
          clearSelection();
          return;
        }

        const species = card.species;
        if (species === "parrot" || species === "chameleon") {
          setSelection({ type: "target", species, handIndex, actions });
          return;
        }

        if (species === "kangaroo") {
          const hopOptions = new Set(
            actions
              .filter((action) => action.params && action.params.length)
              .map((action) => action.params[0])
          );
          if (hopOptions.size > 1) {
            setSelection({ type: "kangaroo", species, handIndex, actions });
            return;
          }
        }

        sendSelectedAction(actions[0]);
      }

      function handleQueueCardClick(queueIndex) {
        if (!pendingSelection) {
          return;
        }

        if (pendingSelection.type === "target") {
          const matches = pendingSelection.actions.filter((action) => action.params?.[0] === queueIndex);
          if (!matches.length) {
            return;
          }

          if (pendingSelection.species === "chameleon") {
            const requiresExtra = matches.some((action) => action.params.length > 1);
            if (requiresExtra) {
              const targetCard = currentState?.zones?.queue?.[queueIndex] ?? null;
              const copiedSpecies = targetCard?.species ?? null;
              setSelection({
                type: "chameleon-extra",
                species: "chameleon",
                copiedSpecies,
                handIndex: pendingSelection.handIndex,
                actions: matches,
              });
              return;
            }
          }

          sendSelectedAction(matches[0]);
          return;
        }

        if (pendingSelection.type === "chameleon-extra") {
          if (pendingSelection.copiedSpecies !== "parrot") {
            return;
          }
          const matches = pendingSelection.actions.filter((action) => action.params?.[1] === queueIndex);
          if (!matches.length) {
            return;
          }
          sendSelectedAction(matches[0]);
        }
      }

      function sendSelectedAction(action) {
        pendingSelection = null;
        render();
        void sendAction(action);
      }

      function winnerMessage(scores) {
        if (scores[0] === scores[1]) {
          return "Game over · Draw";
        }
        const winner = scores[0] > scores[1] ? 0 : 1;
        const diff = Math.abs(scores[0] - scores[1]);
        const margin = diff === 1 ? "by 1 point" : `by ${diff} points`;
        const winnerLabel = playerLabel(winner);
        return `Game over · ${winnerLabel} wins ${margin}`;
      }

      function updateHint() {
        if (!hintEl) {
          return;
        }

        if (!currentState) {
          hintEl.textContent = "";
          return;
        }

        if (pendingSelection) {
          if (pendingSelection.type === "target") {
            if (pendingSelection.species === "parrot") {
              hintEl.textContent = "Select a card in the queue for the parrot to shoo away.";
              return;
            }
            if (pendingSelection.species === "chameleon") {
              hintEl.textContent = "Choose an animal in the queue for the chameleon to imitate.";
              return;
            }
            hintEl.textContent = "Select a target in the queue.";
            return;
          }

          if (pendingSelection.type === "chameleon-extra") {
            const copied = pendingSelection.copiedSpecies;
            if (copied === "parrot") {
              hintEl.textContent = "Pick the card the chameleon's borrowed parrot will shoo away.";
            } else if (copied === "kangaroo") {
              hintEl.textContent = "Choose how far the chameleon's borrowed kangaroo should hop.";
            } else {
              hintEl.textContent = "Pick the option for the copied ability.";
            }
            return;
          }

          if (pendingSelection.type === "kangaroo") {
            hintEl.textContent = "Pick how far the kangaroo should hop.";
            return;
          }
        }

        if (currentState.isTerminal) {
          hintEl.textContent = "Game finished. Start a new game to play again.";
          return;
        }

        const active = currentState.activePlayer;
        const label = playerLabel(active);
        if (currentState.opponent && active !== currentState.humanPlayer) {
          hintEl.textContent = `${label} is thinking…`;
          return;
        }

        const prefix = label === "You" ? "Your turn" : label;
        hintEl.textContent = `${prefix}: click a card in your hand to play it.`;
      }

      function clearRender() {
        queueEl.innerHTML = "";
        handContainers.forEach((el) => (el.innerHTML = ""));
        handWrappers.forEach((wrapper) => wrapper.classList.remove("hand-active"));
        updatePilePreview(beastyPreview, beastyCount, []);
        updatePilePreview(thatsPreview, thatsCount, []);
        pendingSelection = null;
        updatePlayerNames();
        updateHint();
        serverLogEntries = [];
        renderLog();
        if (logCopyBtn) {
          logCopyBtn.disabled = true;
        }
      }

      async function sendAction(action) {
        if (!currentState) return;
        const response = await fetch("/api/action", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(action),
        });
        if (!response.ok) {
          let message = "Move rejected";
          try {
            const data = await response.json();
            if (data?.detail) {
              message = data.detail;
            }
          } catch (error) {
            // ignore
          }
          hintEl.textContent = message;
          addLocalLogEntry({
            message: `Error · ${message}`,
            timestamp: new Date(),
          });
        }
        await refreshState();
      }

      function renderLog() {
        const normalizedServer = (serverLogEntries || []).map((entry) => ({
          id: entry.id,
          turn: entry.turn,
          player: entry.player,
          action: entry.action,
          effects: Array.isArray(entry.effects) ? entry.effects : [],
          timestamp: createTimestamp(entry.timestampMs, entry.timestamp),
          source: "server",
        }));

        const unmatchedLocal = (localLogEntries || []).filter((local) => {
          if (!local.action) {
            return true;
          }
          return !normalizedServer.some(
            (server) =>
              typeof server.turn === "number" &&
              typeof local.turn === "number" &&
              server.turn === local.turn &&
              server.player === local.player &&
              server.action === local.action,
          );
        });

        const combined = [...normalizedServer, ...unmatchedLocal]
          .map((entry) => {
            const stamp = entry.timestamp instanceof Date && !Number.isNaN(entry.timestamp.valueOf())
              ? entry.timestamp
              : new Date();
            return { ...entry, timestamp: stamp };
          })
          .sort((a, b) => b.timestamp.valueOf() - a.timestamp.valueOf());

        logList.innerHTML = "";
        if (!combined.length) {
          const empty = document.createElement("li");
          empty.className = "log-empty";
          empty.textContent = "No turns yet";
          logList.appendChild(empty);
          return;
        }

        combined.forEach((entry) => {
          const item = document.createElement("li");
          item.className = "log-item";
          const time = document.createElement("time");
          const safeDate = entry.timestamp instanceof Date && !Number.isNaN(entry.timestamp.valueOf())
            ? entry.timestamp
            : new Date();
          time.dateTime = safeDate.toISOString();
          time.textContent = safeDate.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          item.appendChild(time);

          const text = document.createElement("div");
          text.textContent = entry.action || entry.message || "";
          item.appendChild(text);

          if (entry.effects && entry.effects.length) {
            const list = document.createElement("ul");
            entry.effects.forEach((effect) => {
              const effectItem = document.createElement("li");
              effectItem.textContent = effect;
              list.appendChild(effectItem);
            });
            item.appendChild(list);
          }
          logList.appendChild(item);
        });
      }

      function addLocalLogEntry(entry) {
        const normalized = {
          id: entry.id || makeId(),
          action: entry.action || entry.message || "",
          effects: Array.isArray(entry.effects) ? entry.effects : [],
          turn: typeof entry.turn === "number" ? entry.turn : null,
          player: typeof entry.player === "number" ? entry.player : null,
          timestamp: entry.timestamp instanceof Date ? entry.timestamp : new Date(),
          source: "local",
        };
        localLogEntries = [normalized, ...localLogEntries].slice(0, 30);
        renderLog();
      }

      function copyTextToClipboard(text) {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
          return navigator.clipboard.writeText(text);
        }
        return new Promise((resolve, reject) => {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.setAttribute("readonly", "true");
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            const successful = document.execCommand("copy");
            document.body.removeChild(textarea);
            if (successful) {
              resolve();
            } else {
              reject(new Error("Copy command was unsuccessful"));
            }
          } catch (error) {
            document.body.removeChild(textarea);
            reject(error);
          }
        });
      }

      function createTimestamp(timestampMs, isoString) {
        if (typeof timestampMs === "number" && Number.isFinite(timestampMs)) {
          const date = new Date(timestampMs);
          if (!Number.isNaN(date.valueOf())) {
            return date;
          }
        }
        if (typeof isoString === "string" && isoString) {
          // Trim fractional seconds beyond milliseconds for broader compatibility.
          const sanitized = isoString.replace(/\.(\d{3})\d*(?=Z|[+-]\d{2}:?\d{2}$)/, ".$1");
          const parsed = new Date(sanitized);
          if (!Number.isNaN(parsed.valueOf())) {
            return parsed;
          }
        }
        return new Date();
      }

      function openPileModal(title, cards) {
        modalTitle.textContent = title;
        modalBody.innerHTML = "";
        const nodes = cards.map((card) => createCard(card));
        if (!nodes.length) {
          const empty = document.createElement("div");
          empty.className = "cards-empty";
          empty.textContent = "Pile empty";
          modalBody.appendChild(empty);
        } else {
          nodes.forEach((node) => modalBody.appendChild(node));
        }
        modalEl.classList.add("modal--open");
        modalEl.setAttribute("aria-hidden", "false");
      }

      function closeModal() {
        modalEl.classList.remove("modal--open");
        modalEl.setAttribute("aria-hidden", "true");
      }

      function populateOpponentOptions() {
        const previous = opponentSelect.value;
        opponentSelect.innerHTML = "";
        const baseOption = document.createElement("option");
        baseOption.value = "";
        baseOption.textContent = "Human vs Human";
        opponentSelect.appendChild(baseOption);
        availableAgents.forEach((name) => {
          const option = document.createElement("option");
          option.value = name;
          option.textContent = name;
          opponentSelect.appendChild(option);
        });
        if (availableAgents.includes(previous)) {
          opponentSelect.value = previous;
        }
      }

      async function loadAgents() {
        try {
          const response = await fetch("/api/agents");
          if (!response.ok) {
            return;
          }
          const data = await response.json();
          const names = Array.isArray(data?.agents) ? data.agents : [];
          availableAgents = names.slice().sort();
          populateOpponentOptions();
        } catch (error) {
          // ignore network issues for optional list
        }
      }

      function makeId() {
        if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
          return crypto.randomUUID();
        }
        return `log-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      loadAgents();
      refreshState();
    </script>
  </body>
</html>

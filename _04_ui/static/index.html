<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beasty Bar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-elevated: #334155;
      --border: #475569;
      --border-light: #64748b;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      --accent: #3b82f6;
      --accent-glow: rgba(59, 130, 246, 0.4);
      --success: #22c55e;
      --success-glow: rgba(34, 197, 94, 0.3);
      --danger: #ef4444;
      --danger-glow: rgba(239, 68, 68, 0.3);
      --warning: #f59e0b;
      --p0-color: #3b82f6;
      --p1-color: #f97316;
      --card-width: 100px;
      --card-height: 140px;
      --queue-card-width: 120px;
      --queue-card-height: 168px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      gap: 1rem;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .turn-badge {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: var(--bg-elevated);
      border-radius: 2rem;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .turn-badge.your-turn {
      background: var(--accent);
      color: white;
      animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 0 var(--accent-glow); }
      50% { box-shadow: 0 0 20px 4px var(--accent-glow); }
    }

    .turn-badge.ai-turn {
      background: var(--p1-color);
      color: white;
    }

    .turn-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    .header-center {
      display: flex;
      align-items: center;
      gap: 2rem;
    }

    .scoreboard {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background: var(--bg-elevated);
      min-width: 80px;
      transition: all 0.2s;
    }

    .score-item.active {
      transform: scale(1.05);
    }

    .score-item[data-player="0"] { border: 2px solid var(--p0-color); }
    .score-item[data-player="1"] { border: 2px solid var(--p1-color); }
    .score-item[data-player="0"].active { box-shadow: 0 0 20px var(--p0-color); }
    .score-item[data-player="1"].active { box-shadow: 0 0 20px var(--p1-color); }

    .score-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .score-value {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .score-divider {
      font-size: 1.25rem;
      color: var(--text-dim);
      font-weight: 300;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.5rem;
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-ai {
      background: var(--p1-color);
      color: white;
      animation: pulse-ai 1.5s ease-in-out infinite;
    }

    @keyframes pulse-ai {
      0%, 100% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4); }
      50% { box-shadow: 0 0 15px 3px rgba(249, 115, 22, 0.4); }
    }

    .btn-ai:hover {
      background: #ea580c;
    }

    /* Game Area */
    .game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    /* Main Board */
    .board {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 1.5rem;
      overflow: hidden;
    }

    /* Side Piles */
    .side-pile {
      width: 140px;
      background: var(--bg-card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      max-height: 100%;
      flex-shrink: 0;
    }

    .pile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .pile-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pile-title.heaven { color: var(--success); }
    .pile-title.hell { color: var(--danger); }

    .pile-count {
      font-size: 0.875rem;
      font-weight: 700;
      color: var(--text-muted);
    }

    .pile-cards {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .pile-card {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.5rem;
      background: var(--bg-elevated);
      border-radius: 0.375rem;
      font-size: 0.8rem;
    }

    .pile-card-owner {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .pile-card-owner[data-owner="0"] { background: var(--p0-color); }
    .pile-card-owner[data-owner="1"] { background: var(--p1-color); }

    .pile-card-name {
      flex: 1;
      text-transform: capitalize;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pile-card-pts {
      color: var(--text-muted);
      font-weight: 600;
    }

    .pile-empty {
      color: var(--text-dim);
      font-size: 0.8rem;
      text-align: center;
      padding: 1rem 0;
    }

    /* Queue */
    .queue-container {
      flex: 1;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .queue-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .queue {
      display: flex;
      gap: 0.75rem;
      padding: 1rem;
      background: var(--bg-card);
      border-radius: 1rem;
      border: 2px dashed var(--border);
      min-height: calc(var(--queue-card-height) + 2rem);
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .queue.targeting {
      border-color: var(--accent);
      background: rgba(59, 130, 246, 0.1);
    }

    .queue-slot {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border: 2px dashed var(--border);
      border-radius: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 0.75rem;
    }

    .queue-direction {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 700px;
      padding: 0 0.5rem;
    }

    .queue-direction span {
      font-size: 0.75rem;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .arrow {
      font-size: 1rem;
    }

    /* Cards */
    .card {
      width: var(--queue-card-width);
      height: var(--queue-card-height);
      border-radius: 0.75rem;
      background: var(--bg-elevated);
      border: 2px solid var(--border);
      position: relative;
      overflow: hidden;
      cursor: default;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
    }

    .card.hand-card {
      width: var(--card-width);
      height: var(--card-height);
    }

    .card-art {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      z-index: 0;
    }

    .card-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, transparent 30%, rgba(0,0,0,0.7) 100%);
      z-index: 1;
    }

    .card-content {
      position: relative;
      z-index: 2;
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0.5rem;
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .card-owner-badge {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .card-owner-badge[data-owner="0"] { background: var(--p0-color); }
    .card-owner-badge[data-owner="1"] { background: var(--p1-color); }

    .card-strength {
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 0.7rem;
      font-weight: 700;
      padding: 0.15rem 0.4rem;
      border-radius: 0.25rem;
    }

    .card-bottom {
      margin-top: auto;
      text-align: center;
    }

    .card-species {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: capitalize;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .card-points {
      font-size: 0.65rem;
      color: rgba(255,255,255,0.8);
    }

    /* Card States */
    .card.playable {
      cursor: pointer;
      border-color: var(--accent);
      box-shadow: 0 0 0 0 var(--accent-glow);
    }

    .card.playable:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 8px 25px var(--accent-glow);
    }

    .card.selected {
      border-color: var(--success);
      box-shadow: 0 0 20px var(--success-glow);
      transform: translateY(-8px) scale(1.05);
    }

    .card.targetable {
      cursor: pointer;
      border-color: var(--warning);
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
      animation: target-pulse 1s ease-in-out infinite;
    }

    @keyframes target-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 0 25px rgba(245, 158, 11, 0.5); }
    }

    .card.targetable:hover {
      transform: scale(1.05);
    }

    .card.dimmed {
      opacity: 0.3;
      filter: grayscale(0.5);
    }

    .card.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .card.no-art {
      background: linear-gradient(135deg, var(--bg-elevated) 0%, var(--bg-card) 100%);
    }

    .card.no-art .card-content {
      justify-content: space-between;
    }

    .card.no-art .card-species {
      font-size: 0.85rem;
    }

    /* Hand */
    .hand-area {
      background: var(--bg-card);
      border-top: 1px solid var(--border);
      padding: 1rem 1.5rem;
      flex-shrink: 0;
    }

    .hand-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .hand-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .hand-cards {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .hand-empty {
      color: var(--text-dim);
      font-size: 0.875rem;
      padding: 2rem;
      text-align: center;
    }

    /* Card Action Buttons */
    .card-actions {
      position: absolute;
      bottom: 0.5rem;
      left: 0.5rem;
      right: 0.5rem;
      z-index: 3;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .card-action-btn {
      padding: 0.3rem 0.5rem;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 0.375rem;
      color: white;
      font-size: 0.65rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .card-action-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Hint */
    .hint-bar {
      background: var(--bg-elevated);
      border-top: 1px solid var(--border);
      padding: 0.75rem 1.5rem;
      text-align: center;
      font-size: 0.875rem;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .hint-bar.action-hint {
      background: linear-gradient(90deg, var(--bg-elevated), rgba(59, 130, 246, 0.2), var(--bg-elevated));
      color: var(--text);
    }

    /* Splash / Welcome Screen */
    .splash-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg-dark);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s, visibility 0.4s;
    }

    .splash-overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .splash-content {
      text-align: center;
      max-width: 600px;
      padding: 2rem;
    }

    .splash-title {
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.75rem;
    }

    .splash-subtitle {
      font-size: 1.1rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      line-height: 1.6;
    }

    .splash-stats {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin: 1.5rem 0 2rem;
    }

    .splash-stat {
      text-align: center;
    }

    .splash-stat-value {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--text);
    }

    .splash-stat-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .splash-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
    }

    .splash-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      width: 320px;
      padding: 1rem 1.5rem;
      border: none;
      border-radius: 0.75rem;
      font-family: inherit;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .splash-btn-primary {
      background: linear-gradient(135deg, var(--accent), #6366f1);
      color: white;
      font-size: 1.1rem;
    }

    .splash-btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
    }

    .splash-btn-secondary {
      background: var(--bg-card);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .splash-btn-secondary:hover {
      background: var(--bg-elevated);
      transform: translateY(-1px);
    }

    .splash-btn-ghost {
      background: transparent;
      color: var(--text-muted);
      font-size: 0.875rem;
      font-weight: 400;
      width: auto;
      padding: 0.5rem 1rem;
    }

    .splash-btn-ghost:hover {
      color: var(--text);
    }

    .splash-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background: rgba(59, 130, 246, 0.15);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 2rem;
      font-size: 0.75rem;
      color: var(--accent);
      margin-bottom: 1rem;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      transform: scale(0.9);
      transition: transform 0.2s;
    }

    .modal-overlay.visible .modal {
      transform: scale(1);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .modal-field {
      margin-bottom: 1rem;
    }

    .modal-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .modal-input,
    .modal-select {
      width: 100%;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      color: var(--text);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .modal-input:focus,
    .modal-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .modal-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Stats Table */
    .stats-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem;
    }

    .stats-table th,
    .stats-table td {
      padding: 0.75rem 0.5rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
    }

    .stats-table th {
      font-weight: 600;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stats-table td:first-child {
      text-align: left;
      font-weight: 500;
    }

    .stats-table tr:last-child td {
      border-bottom: none;
    }

    .stats-table .win-rate {
      font-weight: 600;
    }

    .stats-table .win-rate.good {
      color: var(--success);
    }

    .stats-table .win-rate.bad {
      color: var(--danger);
    }

    .stats-table .win-rate.neutral {
      color: var(--warning);
    }

    .stats-total-row {
      background: var(--bg-elevated);
      font-weight: 600;
    }

    .stats-total-row td:first-child {
      font-weight: 700;
    }

    /* Game Over Overlay */
    .game-over-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }

    .game-over-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .game-over-title {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .game-over-title.win {
      background: linear-gradient(135deg, var(--success), #4ade80);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-over-title.lose {
      color: var(--danger);
    }

    .game-over-title.draw {
      color: var(--warning);
    }

    .game-over-score {
      font-size: 1.5rem;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .header {
        flex-wrap: wrap;
        padding: 0.75rem 1rem;
      }

      .header-center {
        order: 3;
        width: 100%;
        justify-content: center;
      }

      .board {
        flex-direction: column;
        padding: 1rem;
      }

      .side-pile {
        width: 100%;
        max-height: 120px;
        flex-direction: row;
        gap: 1rem;
      }

      .pile-header {
        flex-direction: column;
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
        border-right: 1px solid var(--border);
        padding-right: 1rem;
      }

      .pile-cards {
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .queue {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 600px) {
      :root {
        --card-width: 80px;
        --card-height: 112px;
        --queue-card-width: 90px;
        --queue-card-height: 126px;
      }

      .logo {
        font-size: 1rem;
      }

      .score-item {
        min-width: 60px;
        padding: 0.375rem 0.75rem;
      }

      .score-value {
        font-size: 1.25rem;
      }
    }

    /* ===================== AI Battle Mode ===================== */

    /* Battle Mode Container - wraps game area + sidebar */
    .battle-wrapper {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .battle-wrapper.active {
      display: flex;
    }

    /* Hide normal game area when in battle mode */
    body.battle-mode .game-area,
    body.battle-mode .hand-area,
    body.battle-mode .hint-bar {
      display: none;
    }

    body.battle-mode .battle-wrapper {
      display: flex;
    }

    /* Battle main content (board + hands) */
    .battle-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Battle board area */
    .battle-board {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 1rem;
      overflow: hidden;
    }

    /* Dual hand areas */
    .battle-hand {
      background: var(--bg-card);
      border: 1px solid var(--border);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .battle-hand-top {
      border-radius: 0 0 0.75rem 0.75rem;
      border-top: 2px solid var(--p0-color);
    }

    .battle-hand-bottom {
      border-radius: 0.75rem 0.75rem 0 0;
      border-bottom: 2px solid var(--p1-color);
    }

    .battle-hand-label {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
      padding: 0.5rem 0;
    }

    .battle-hand-top .battle-hand-label { color: var(--p0-color); }
    .battle-hand-bottom .battle-hand-label { color: var(--p1-color); }

    .battle-hand-cards {
      display: flex;
      gap: 0.5rem;
      min-height: 100px;
    }

    .battle-hand .card {
      width: 80px;
      height: 112px;
    }

    .battle-hand .hand-empty {
      color: var(--text-dim);
      font-size: 0.8rem;
      padding: 1rem 2rem;
    }

    /* Active player highlight in battle mode */
    .battle-hand.active-player {
      box-shadow: 0 0 20px var(--accent-glow);
      border-color: var(--accent);
    }

    /* Battle Scoreboard Sidebar */
    .battle-sidebar {
      width: 280px;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .battle-sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }

    .battle-sidebar-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 0.25rem;
    }

    .battle-sidebar-subtitle {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .battle-scores {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .battle-score-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .battle-score-row:last-child {
      margin-bottom: 0;
    }

    .battle-score-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .battle-score-row[data-player="0"] .battle-score-color { background: var(--p0-color); }
    .battle-score-row[data-player="1"] .battle-score-color { background: var(--p1-color); }

    .battle-score-name {
      flex: 1;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .battle-score-wins {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .battle-score-row[data-player="0"] .battle-score-wins { color: var(--p0-color); }
    .battle-score-row[data-player="1"] .battle-score-wins { color: var(--p1-color); }

    .battle-progress {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .battle-progress-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .battle-progress-bar {
      height: 8px;
      background: var(--bg-elevated);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .battle-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--p0-color), var(--p1-color));
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .battle-progress-text {
      font-size: 0.875rem;
      color: var(--text);
      text-align: center;
    }

    .battle-winrate {
      padding: 1rem;
      flex: 1;
    }

    .battle-winrate-bar {
      display: flex;
      height: 24px;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .battle-winrate-p0 {
      background: var(--p0-color);
      transition: width 0.3s ease;
    }

    .battle-winrate-p1 {
      background: var(--p1-color);
      transition: width 0.3s ease;
    }

    .battle-winrate-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Playback Controls */
    .battle-controls {
      padding: 1rem;
      background: var(--bg-dark);
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .battle-controls-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .battle-play-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: white;
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .battle-play-btn:hover {
      background: #2563eb;
      transform: scale(1.05);
    }

    .battle-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .battle-speed-control {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .battle-speed-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .battle-speed-slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-elevated);
      border-radius: 3px;
      outline: none;
    }

    .battle-speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: transform 0.15s;
    }

    .battle-speed-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .battle-exit-btn {
      padding: 0.5rem 1rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      color: var(--text);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .battle-exit-btn:hover {
      background: var(--border);
    }

    /* Battle Setup Modal */
    .battle-setup-field {
      display: flex;
      gap: 1rem;
    }

    .battle-setup-field .modal-field {
      flex: 1;
    }

    /* Ability highlight effects */
    .card.event-kill {
      animation: event-kill 0.5s ease-out;
    }

    @keyframes event-kill {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--danger-glow); }
    }

    .card.event-move {
      animation: event-move 0.5s ease-out;
    }

    @keyframes event-move {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--warning); }
    }

    .card.event-score {
      animation: event-score 0.5s ease-out;
    }

    @keyframes event-score {
      0%, 100% { box-shadow: none; }
      50% { box-shadow: 0 0 20px 5px var(--success-glow); }
    }

    /* ===================== Card Animations ===================== */

    /* Animation timing variables - much slower for clarity */
    :root {
      --anim-fast: 500ms;
      --anim-normal: 700ms;
      --anim-slow: 900ms;
      --anim-very-slow: 1200ms;
      --anim-easing: cubic-bezier(0.25, 0.1, 0.25, 1);
      --anim-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Card flying to queue animation - smooth arc with lift */
    @keyframes card-fly-to-queue {
      0% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      15% {
        opacity: 1;
        transform: scale(1.08) rotate(-2deg) translateY(-20px);
      }
      50% {
        opacity: 1;
        transform: translate(calc(var(--fly-x) * 0.6), calc(var(--fly-y) * 0.4 - 80px)) scale(1.12) rotate(3deg);
      }
      85% {
        opacity: 1;
        transform: translate(calc(var(--fly-x) * 0.95), calc(var(--fly-y) * 0.9)) scale(1.02) rotate(-1deg);
      }
      100% {
        opacity: 1;
        transform: translate(var(--fly-x), var(--fly-y)) scale(1) rotate(0deg);
      }
    }

    .card.animating-to-queue {
      position: fixed !important;
      z-index: 1000;
      animation: card-fly-to-queue var(--anim-normal) cubic-bezier(0.22, 1, 0.36, 1) forwards;
      pointer-events: none;
      /* Ensure card is visible */
      background: var(--bg-elevated);
      border: 2px solid var(--accent);
      border-radius: 0.75rem;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 0 20px rgba(59, 130, 246, 0.3);
    }

    /* Kill effect - card dies dramatically */
    @keyframes card-kill-effect {
      0% {
        transform: scale(1) rotate(0deg);
        filter: brightness(1);
        opacity: 1;
      }
      15% {
        transform: scale(1.15) rotate(0deg);
        filter: brightness(1.8);
        box-shadow: 0 0 40px var(--danger), 0 0 60px var(--danger);
      }
      30% {
        transform: scale(1.1) rotate(0deg);
        filter: brightness(1.4) saturate(0.3);
        box-shadow: 0 0 30px var(--danger);
      }
      50% {
        transform: scale(0.9) rotate(5deg) translateY(10px);
        filter: brightness(0.8) saturate(0.2);
        opacity: 0.8;
      }
      75% {
        transform: scale(0.7) rotate(-8deg) translateY(30px) translateX(20px);
        opacity: 0.4;
      }
      100% {
        transform: scale(0.4) rotate(15deg) translateY(80px) translateX(40px);
        opacity: 0;
      }
    }

    .card.animating-kill {
      animation: card-kill-effect var(--anim-slow) var(--anim-easing) forwards;
      pointer-events: none;
      z-index: 100;
    }

    /* Heaven's Gate entry - card scores with celebration */
    @keyframes card-to-heaven {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
      20% {
        transform: translateX(10px) scale(1.12);
        box-shadow: 0 0 30px var(--success), 0 0 50px var(--success-glow);
        filter: brightness(1.3);
      }
      40% {
        transform: translateX(-30px) scale(1.08);
        box-shadow: 0 0 40px var(--success);
      }
      100% {
        transform: translateX(-200px) scale(0.6);
        opacity: 0;
      }
    }

    .card.animating-score {
      animation: card-to-heaven var(--anim-slow) var(--anim-easing) forwards;
      pointer-events: none;
      z-index: 100;
    }

    /* That's It entry - card bounces to hell pile */
    @keyframes card-to-hell {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
      30% {
        transform: translateX(15px) scale(1.05);
        box-shadow: 0 0 20px var(--danger-glow);
      }
      100% {
        transform: translateX(150px) scale(0.7);
        opacity: 0;
      }
    }

    .card.animating-to-hell {
      animation: card-to-hell 220ms var(--anim-easing) forwards;
      pointer-events: none;
      z-index: 100;
    }

    /* Queue reorder - smooth position transition */
    .card.animating-move {
      transition: transform var(--anim-fast) var(--anim-easing);
      z-index: 50;
    }

    /* Queue reversal flash (seal ability) */
    @keyframes queue-reverse-flash {
      0% {
        background: var(--bg-card);
        border-color: var(--border);
        box-shadow: none;
      }
      25% {
        background: rgba(139, 92, 246, 0.25);
        border-color: #8b5cf6;
        box-shadow: inset 0 0 30px rgba(139, 92, 246, 0.4), 0 0 20px rgba(139, 92, 246, 0.3);
      }
      50% {
        background: rgba(139, 92, 246, 0.15);
        border-color: #8b5cf6;
        box-shadow: inset 0 0 20px rgba(139, 92, 246, 0.2);
      }
      75% {
        background: rgba(139, 92, 246, 0.2);
        border-color: #8b5cf6;
        box-shadow: inset 0 0 25px rgba(139, 92, 246, 0.3), 0 0 15px rgba(139, 92, 246, 0.2);
      }
      100% {
        background: var(--bg-card);
        border-color: var(--border);
        box-shadow: none;
      }
    }

    .queue.animating-reverse {
      animation: queue-reverse-flash 600ms ease-in-out;
    }

    /* Card appearing in queue (after fly animation completes or AI play) */
    @keyframes card-appear {
      0% {
        transform: scale(0.3) translateY(30px);
        opacity: 0;
        box-shadow: 0 0 0 rgba(59, 130, 246, 0);
      }
      50% {
        transform: scale(1.1) translateY(-5px);
        opacity: 1;
        box-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
      }
      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
        box-shadow: none;
      }
    }

    .card.animating-appear {
      animation: card-appear 500ms var(--anim-bounce) forwards;
    }

    /* Card being played - fade out smoothly while clone flies */
    .card.animating-playing {
      animation: card-playing-out 500ms ease-out forwards;
      pointer-events: none;
      z-index: 500;
    }

    @keyframes card-playing-out {
      0% {
        transform: scale(1);
        opacity: 1;
        filter: brightness(1);
      }
      20% {
        transform: scale(1.08) translateY(-15px);
        opacity: 0.95;
        filter: brightness(1.2);
        box-shadow: 0 15px 40px rgba(59, 130, 246, 0.4);
      }
      60% {
        transform: scale(0.9) translateY(-25px);
        opacity: 0.5;
        filter: brightness(0.9);
      }
      100% {
        transform: scale(0.7) translateY(-35px);
        opacity: 0;
        filter: brightness(0.7);
      }
    }

    /* Stagger animation delays for multiple cards */
    .card.anim-delay-1 { animation-delay: 100ms; }
    .card.anim-delay-2 { animation-delay: 200ms; }
    .card.anim-delay-3 { animation-delay: 300ms; }
    .card.anim-delay-4 { animation-delay: 400ms; }

    /* Animation label that shows what's happening */
    .anim-label {
      position: fixed;
      font-size: 1.5rem;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      pointer-events: none;
      z-index: 2000;
      text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px currentColor;
      animation: anim-label-pop 1s var(--anim-easing) forwards;
    }

    .anim-label.kill { color: #ef4444; }
    .anim-label.score { color: #22c55e; }
    .anim-label.hop { color: #f59e0b; }
    .anim-label.reverse { color: #8b5cf6; }
    .anim-label.roar { color: #f97316; }
    .anim-label.order { color: #06b6d4; }
    .anim-label.push { color: #ec4899; }
    .anim-label.swap { color: #14b8a6; }
    .anim-label.move { color: #a855f7; }

    @keyframes anim-label-pop {
      0% {
        opacity: 0;
        transform: scale(0.5) translateY(20px);
      }
      20% {
        opacity: 1;
        transform: scale(1.3) translateY(-10px);
      }
      50% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      80% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(0.8) translateY(-30px);
      }
    }

    /* Card hopping animation (kangaroo) */
    @keyframes card-hop {
      0% { transform: translateY(0); }
      25% { transform: translateY(-40px) scale(1.1); }
      50% { transform: translateY(-60px) scale(1.15); }
      75% { transform: translateY(-30px) scale(1.05); }
      100% { transform: translateY(0) scale(1); }
    }

    .card.animating-hop {
      animation: card-hop 500ms var(--anim-bounce);
      z-index: 200;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }

    /* Card push animation (hippo) */
    @keyframes card-push {
      0% { transform: translateX(0) scale(1); }
      20% { transform: translateX(-15px) scale(1.05); }
      40% { transform: translateX(30px) scale(1.15); }
      60% { transform: translateX(20px) scale(1.1); }
      80% { transform: translateX(10px) scale(1.02); }
      100% { transform: translateX(0) scale(1); }
    }

    .card.animating-push {
      animation: card-push 400ms var(--anim-easing);
      z-index: 200;
      box-shadow: 0 0 30px rgba(236, 72, 153, 0.5);
    }

    /* Card roar animation (lion) */
    @keyframes card-roar {
      0% { transform: scale(1); filter: brightness(1); }
      15% { transform: scale(1.2); filter: brightness(1.3); }
      30% { transform: scale(1.15); filter: brightness(1.5); }
      50% { transform: scale(1.25); filter: brightness(1.2); }
      70% { transform: scale(1.1); filter: brightness(1.1); }
      100% { transform: scale(1); filter: brightness(1); }
    }

    .card.animating-roar {
      animation: card-roar 450ms var(--anim-easing);
      z-index: 200;
      box-shadow: 0 0 40px rgba(249, 115, 22, 0.6);
    }

    /* Highlight card being affected */
    .card.highlight-target {
      box-shadow: 0 0 0 4px var(--warning), 0 0 30px var(--warning);
      transition: box-shadow 200ms ease;
    }

    .card.highlight-kill {
      box-shadow: 0 0 0 4px var(--danger), 0 0 30px var(--danger);
    }

    .card.highlight-score {
      box-shadow: 0 0 0 4px var(--success), 0 0 30px var(--success);
    }

    /* Loading overlay for battle computation */
    .battle-loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .battle-loading-overlay.visible {
      display: flex;
    }

    .battle-loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem 3rem;
      background: var(--bg-card);
      border-radius: 1rem;
      border: 1px solid var(--border);
      min-width: 300px;
    }

    .battle-loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .battle-loading-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    .battle-loading-subtitle {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .battle-loading-progress {
      width: 100%;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      overflow: hidden;
    }

    .battle-loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #8b5cf6);
      border-radius: 3px;
      width: 0%;
      animation: loading-pulse 2s ease-in-out infinite;
    }

    @keyframes loading-pulse {
      0%, 100% { width: 20%; margin-left: 0%; }
      50% { width: 60%; margin-left: 40%; }
    }

    .battle-loading-eta {
      font-size: 0.875rem;
      color: var(--accent);
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- Splash / Welcome Screen -->
  <div class="splash-overlay" id="splash">
    <div class="splash-content">
      <div class="splash-badge">Built with Claude Code</div>
      <div class="splash-title">Beasty Bar AI</div>
      <div class="splash-subtitle">
        A Transformer neural network trained through 15 million games of self-play<br>
        to master the card game <a href="https://www.zoch-verlag.com/zoch_en/brands/beasty-bar/" target="_blank" style="color: var(--accent); text-decoration: none;">Beasty Bar</a> using reinforcement learning.
      </div>
      <div class="splash-stats">
        <div class="splash-stat">
          <div class="splash-stat-value">75.7%</div>
          <div class="splash-stat-label">Win Rate</div>
        </div>
        <div class="splash-stat">
          <div class="splash-stat-value">15M</div>
          <div class="splash-stat-label">Games Trained</div>
        </div>
        <div class="splash-stat">
          <div class="splash-stat-value">1.3M</div>
          <div class="splash-stat-label">Parameters</div>
        </div>
        <div class="splash-stat">
          <div class="splash-stat-value">200x</div>
          <div class="splash-stat-label">Cython Speedup</div>
        </div>
      </div>
      <div style="color: var(--text-dim); font-size: 0.8rem; margin-bottom: 1.5rem; line-height: 1.5;">
        PPO self-play on A100 GPUs &bull; 988-dim observation space &bull; 124 discrete actions<br>
        Beats 10 different opponent types &bull; ~1379 ELO
      </div>
      <div class="splash-actions">
        <button class="splash-btn splash-btn-primary" id="splash-watch">
          Watch AI vs AI Battle
        </button>
        <button class="splash-btn splash-btn-secondary" id="splash-play">
          Play Against the AI
        </button>
        <a class="splash-btn splash-btn-ghost" href="https://github.com/diegooprime/beastybar" target="_blank">
          View on GitHub
        </a>
      </div>
    </div>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">Beasty Bar</div>
      <div id="turn-badge" class="turn-badge">
        <span class="turn-dot"></span>
        <span id="turn-text">Loading...</span>
      </div>
    </div>

    <div class="header-center">
      <div class="scoreboard">
        <div class="score-item" data-player="0">
          <span class="score-label" id="score-label-0">You</span>
          <span class="score-value" id="score-0">0</span>
        </div>
        <span class="score-divider">:</span>
        <div class="score-item" data-player="1">
          <span class="score-label" id="score-label-1">AI</span>
          <span class="score-value" id="score-1">0</span>
        </div>
      </div>
    </div>

    <div class="header-right">
      <button id="ai-move-btn" class="btn btn-ai" style="display: none;">
        AI Move
      </button>
      <button id="stats-btn" class="btn btn-secondary">üìä Stats</button>
      <button id="ai-battle-btn" class="btn btn-secondary">AI Battle</button>
      <button id="new-game-btn" class="btn btn-secondary">New Game</button>
    </div>
  </header>

  <!-- Game Area -->
  <div class="game-area">
    <div class="board">
      <!-- Heaven's Gate (Left) -->
      <div class="side-pile" id="heaven-pile">
        <div class="pile-header">
          <span class="pile-title heaven">Heaven's Gate</span>
          <span class="pile-count" id="heaven-count">0</span>
        </div>
        <div class="pile-cards" id="heaven-cards"></div>
      </div>

      <!-- Queue (Center) -->
      <div class="queue-container">
        <div class="queue-direction">
          <span><span class="arrow">‚Üê</span> Heaven's Gate</span>
          <span class="queue-label">Queue</span>
          <span>That's It <span class="arrow">‚Üí</span></span>
        </div>
        <div class="queue" id="queue"></div>
      </div>

      <!-- That's It (Right) -->
      <div class="side-pile" id="hell-pile">
        <div class="pile-header">
          <span class="pile-title hell">That's It</span>
          <span class="pile-count" id="hell-count">0</span>
        </div>
        <div class="pile-cards" id="hell-cards"></div>
      </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="game-over-overlay" id="game-over">
      <div class="game-over-title" id="game-over-title">Victory!</div>
      <div class="game-over-score" id="game-over-score">12 - 8</div>
      <button class="btn btn-primary" id="play-again-btn">Play Again</button>
    </div>
  </div>

  <!-- Hand -->
  <div class="hand-area">
    <div class="hand-header">
      <span class="hand-title">Your Hand</span>
    </div>
    <div class="hand-cards" id="hand"></div>
  </div>

  <!-- Hint Bar -->
  <div class="hint-bar" id="hint">Select a card to play</div>

  <!-- Battle Mode Container -->
  <div class="battle-wrapper" id="battle-wrapper">
    <div class="battle-main">
      <!-- Loading Overlay -->
      <div class="battle-loading-overlay" id="battle-loading-overlay">
        <div class="battle-loading-content">
          <div class="battle-loading-spinner"></div>
          <div class="battle-loading-title" id="battle-loading-title">Computing games...</div>
          <div class="battle-loading-subtitle" id="battle-loading-subtitle">This may take a moment</div>
          <div class="battle-loading-progress">
            <div class="battle-loading-progress-bar" id="battle-loading-progress-bar"></div>
          </div>
          <div class="battle-loading-eta" id="battle-loading-eta">Estimated: ~5 seconds</div>
        </div>
      </div>

      <!-- Player 0 Hand (Top) -->
      <div class="battle-hand battle-hand-top" id="battle-hand-0">
        <span class="battle-hand-label" id="battle-hand-label-0">Player 1</span>
        <div class="battle-hand-cards" id="battle-hand-cards-0"></div>
      </div>

      <!-- Battle Board -->
      <div class="battle-board">
        <!-- Heaven's Gate (Left) -->
        <div class="side-pile" id="battle-heaven-pile">
          <div class="pile-header">
            <span class="pile-title heaven">Heaven's Gate</span>
            <span class="pile-count" id="battle-heaven-count">0</span>
          </div>
          <div class="pile-cards" id="battle-heaven-cards"></div>
        </div>

        <!-- Queue (Center) -->
        <div class="queue-container">
          <div class="queue-direction">
            <span><span class="arrow">‚Üê</span> Heaven's Gate</span>
            <span class="queue-label">Queue</span>
            <span>That's It <span class="arrow">‚Üí</span></span>
          </div>
          <div class="queue" id="battle-queue"></div>
        </div>

        <!-- That's It (Right) -->
        <div class="side-pile" id="battle-hell-pile">
          <div class="pile-header">
            <span class="pile-title hell">That's It</span>
            <span class="pile-count" id="battle-hell-count">0</span>
          </div>
          <div class="pile-cards" id="battle-hell-cards"></div>
        </div>
      </div>

      <!-- Player 1 Hand (Bottom) -->
      <div class="battle-hand battle-hand-bottom" id="battle-hand-1">
        <span class="battle-hand-label" id="battle-hand-label-1">Player 2</span>
        <div class="battle-hand-cards" id="battle-hand-cards-1"></div>
      </div>
    </div>

    <!-- Battle Sidebar -->
    <div class="battle-sidebar">
      <div class="battle-sidebar-header">
        <div class="battle-sidebar-title">AI Battle</div>
        <div class="battle-sidebar-subtitle" id="battle-matchup">Neural vs Heuristic</div>
      </div>

      <div class="battle-scores">
        <div class="battle-score-row" data-player="0">
          <span class="battle-score-color"></span>
          <span class="battle-score-name" id="battle-p0-name">Player 1</span>
          <span class="battle-score-wins" id="battle-p0-wins">0</span>
        </div>
        <div class="battle-score-row" data-player="1">
          <span class="battle-score-color"></span>
          <span class="battle-score-name" id="battle-p1-name">Player 2</span>
          <span class="battle-score-wins" id="battle-p1-wins">0</span>
        </div>
      </div>

      <div class="battle-progress">
        <div class="battle-progress-label">Progress</div>
        <div class="battle-progress-bar">
          <div class="battle-progress-fill" id="battle-progress-fill" style="width: 0%"></div>
        </div>
        <div class="battle-progress-text" id="battle-progress-text">Game 0 / 0</div>
      </div>

      <div class="battle-winrate">
        <div class="battle-progress-label">Win Rate</div>
        <div class="battle-winrate-bar">
          <div class="battle-winrate-p0" id="battle-winrate-p0" style="width: 50%"></div>
          <div class="battle-winrate-p1" id="battle-winrate-p1" style="width: 50%"></div>
        </div>
        <div class="battle-winrate-labels">
          <span id="battle-winrate-p0-pct">50%</span>
          <span id="battle-winrate-p1-pct">50%</span>
        </div>
      </div>

      <div class="battle-controls">
        <div class="battle-controls-row">
          <button class="battle-play-btn" id="battle-play-btn" title="Play/Pause">‚ñ∂</button>
          <div class="battle-speed-control">
            <span class="battle-speed-label">Speed: <span id="battle-speed-value">200ms</span></span>
            <input type="range" class="battle-speed-slider" id="battle-speed-slider"
                   min="50" max="1000" value="200" step="50">
          </div>
        </div>
        <button class="battle-exit-btn" id="battle-exit-btn">Exit Battle Mode</button>
      </div>
    </div>
  </div>

  <!-- Battle Setup Modal -->
  <div class="modal-overlay" id="battle-modal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-title">AI Battle Setup</div>

      <div class="battle-setup-field">
        <div class="modal-field">
          <label class="modal-label">Player 1 (Blue)</label>
          <select class="modal-select" id="battle-p1-select">
            <option value="heuristic">Heuristic</option>
          </select>
        </div>
        <div class="modal-field">
          <label class="modal-label">Player 2 (Orange)</label>
          <select class="modal-select" id="battle-p2-select">
            <option value="random">Random</option>
          </select>
        </div>
      </div>

      <div class="modal-field">
        <label class="modal-label">Number of Games (1-200)</label>
        <input type="number" class="modal-input" id="battle-games-input"
               value="50" min="1" max="200" placeholder="50">
      </div>

      <div class="modal-field" style="display: flex; align-items: center; gap: 8px;">
        <input type="checkbox" id="battle-viz-mode" style="width: 18px; height: 18px;">
        <label for="battle-viz-mode" class="modal-label" style="margin: 0; cursor: pointer;">
          Also open Neural Visualizer (second window with network activations)
        </label>
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="battle-cancel">Cancel</button>
        <button class="btn btn-primary" id="battle-start">Start Battle</button>
      </div>
    </div>
  </div>

  <!-- Claude Move Modal -->
  <div class="modal-overlay" id="claude-modal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-title">Claude's Turn</div>
      <div class="modal-field">
        <label class="modal-label">Copy this to Claude Code:</label>
        <textarea class="modal-input" id="claude-state" readonly rows="12" style="font-family: monospace; font-size: 0.8rem; resize: vertical;"></textarea>
      </div>
      <div class="modal-field">
        <button class="btn btn-secondary" id="copy-state-btn" style="width: 100%;">Copy to Clipboard</button>
      </div>
      <div class="modal-field">
        <label class="modal-label">Enter Claude's response (action number):</label>
        <input type="text" class="modal-input" id="claude-move-input" placeholder="e.g., 1 or 2">
      </div>
      <div class="modal-actions">
        <button class="btn btn-primary" id="submit-claude-move" style="flex: 1;">Submit Move</button>
      </div>
    </div>
  </div>

  <!-- New Game Modal -->
  <div class="modal-overlay" id="new-game-modal">
    <div class="modal">
      <div class="modal-title">New Game</div>

      <div class="modal-field">
        <label class="modal-label">Opponent</label>
        <select class="modal-select" id="ai-select">
          <!-- Dynamically populated from /api/ai-agents -->
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">You Play As</label>
        <select class="modal-select" id="player-select">
          <option value="0">Player 1 (Blue, goes first)</option>
          <option value="1">Player 2 (Orange)</option>
        </select>
      </div>

      <div class="modal-field">
        <label class="modal-label">Seed (optional)</label>
        <input type="number" class="modal-input" id="seed-input" placeholder="Random">
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancel-modal">Cancel</button>
        <button class="btn btn-primary" id="start-game">Start Game</button>
      </div>
    </div>
  </div>

  <!-- Stats Modal -->
  <div class="modal-overlay" id="stats-modal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-title">üìä Your Stats</div>
      <div id="stats-content">
        <table class="stats-table">
          <thead>
            <tr>
              <th>Opponent</th>
              <th>Wins</th>
              <th>Losses</th>
              <th>Draws</th>
              <th>Win %</th>
            </tr>
          </thead>
          <tbody id="stats-table-body">
            <!-- Populated by JS -->
          </tbody>
        </table>
        <div id="stats-empty" style="text-align: center; color: var(--text-muted); padding: 2rem; display: none;">
          No games played yet. Start a game to track your stats!
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" id="stats-clear-btn">Clear Stats</button>
        <button class="btn btn-primary" id="stats-close-btn">Close</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let gameState = null;
    let pendingSelection = null;
    let isFirstLoad = true;
    let aiMoveTimeout = null;
    let currentOpponentId = null;
    let currentOpponentName = null;
    let gameResultRecorded = false;

    // ===================== Animation System =====================

    // Animation state
    let previousGameState = null;
    let isAnimating = false;
    let playingCardKey = null;

    // Animation timing constants (ms) - much slower for clarity
    const ANIM_TIMING = {
      CARD_TO_QUEUE: 700,
      QUEUE_REORDER: 600,
      KILL_EFFECT: 900,
      SCORE_ENTRY: 900,
      HELL_ENTRY: 700,
      STAGGER_DELAY: 200,
      PHASE_GAP: 400
    };

    // Generate unique key for a card
    function getCardKey(card) {
      if (!card) return null;
      return `${card.owner}-${card.species}`;
    }

    // Position tracker for FLIP animations
    const positionTracker = {
      positions: new Map(),

      captureAll() {
        this.positions.clear();
        // Capture hand cards
        const handCards = document.querySelectorAll('#hand .card');
        console.log('[ANIM] Found hand cards:', handCards.length);
        handCards.forEach((el, idx) => {
          const key = el.dataset.cardKey;
          console.log('[ANIM] Hand card', idx, 'key:', key);
          if (key) {
            this.positions.set(key, {
              rect: el.getBoundingClientRect(),
              container: 'hand',
              index: idx,
              element: el
            });
          }
        });
        // Capture queue cards
        const queueCards = document.querySelectorAll('#queue .card');
        console.log('[ANIM] Found queue cards:', queueCards.length);
        queueCards.forEach((el, idx) => {
          const key = el.dataset.cardKey;
          if (key) {
            this.positions.set(key, {
              rect: el.getBoundingClientRect(),
              container: 'queue',
              index: idx,
              element: el
            });
          }
        });
        console.log('[ANIM] Total positions captured:', this.positions.size);
      },

      getPosition(cardKey) {
        return this.positions.get(cardKey);
      },

      clear() {
        this.positions.clear();
      }
    };

    // Animation utilities
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function waitForAnimation(element, fallbackMs = 300) {
      return new Promise(resolve => {
        const handler = () => {
          element.removeEventListener('animationend', handler);
          resolve();
        };
        element.addEventListener('animationend', handler);
        // Fallback in case animation doesn't fire
        setTimeout(resolve, fallbackMs);
      });
    }

    // Clone a card element for animation
    function cloneCardForAnimation(originalEl) {
      const clone = originalEl.cloneNode(true);
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '1000';
      return clone;
    }

    // Show animation label at a position
    function showAnimLabel(text, x, y, type) {
      const label = document.createElement('div');
      label.className = `anim-label ${type}`;
      label.textContent = text;
      label.style.left = x + 'px';
      label.style.top = y + 'px';
      document.body.appendChild(label);

      // Remove after animation
      setTimeout(() => {
        label.remove();
      }, 1000);

      return label;
    }

    // Show label near a card element
    function showLabelNearCard(cardEl, text, type) {
      if (!cardEl) return;
      const rect = cardEl.getBoundingClientRect();
      showAnimLabel(text, rect.left + rect.width / 2 - 30, rect.top - 40, type);
    }

    // Find queue element target position
    function getQueueTargetPosition() {
      const queue = document.getElementById('queue');
      const queueRect = queue.getBoundingClientRect();
      const existingCards = queue.querySelectorAll('.card');

      if (existingCards.length > 0) {
        // Position after last card
        const lastCard = existingCards[existingCards.length - 1];
        const lastRect = lastCard.getBoundingClientRect();
        return {
          x: lastRect.right + 12, // gap
          y: lastRect.top + lastRect.height / 2
        };
      }
      // Center of queue
      return {
        x: queueRect.left + queueRect.width / 2,
        y: queueRect.top + queueRect.height / 2
      };
    }

    // Animate card flying from hand to queue
    async function animateCardToQueue(cardKey, sourceRect) {
      console.log('[ANIM] animateCardToQueue called', cardKey, sourceRect);
      if (!sourceRect) {
        console.log('[ANIM] No sourceRect, returning');
        return;
      }

      // Find and fade the original card in hand
      const originalCard = document.querySelector(`#hand .card[data-card-key="${cardKey}"]`);
      if (originalCard) {
        originalCard.classList.add('animating-playing');
      }

      // Small delay to let the lift animation start
      await delay(100);

      // Find where the card will land in queue
      const targetPos = getQueueTargetPosition();

      // Create flying card clone
      const flyingCard = document.createElement('div');
      flyingCard.className = 'card hand-card animating-to-queue';
      flyingCard.style.width = sourceRect.width + 'px';
      flyingCard.style.height = sourceRect.height + 'px';
      flyingCard.style.left = sourceRect.left + 'px';
      flyingCard.style.top = sourceRect.top + 'px';

      // Calculate delta
      const deltaX = targetPos.x - sourceRect.left - sourceRect.width / 2;
      const deltaY = targetPos.y - sourceRect.top - sourceRect.height / 2;

      flyingCard.style.setProperty('--fly-x', deltaX + 'px');
      flyingCard.style.setProperty('--fly-y', deltaY + 'px');

      // Copy card appearance
      if (previousGameState) {
        const hand = previousGameState.hands[previousGameState.humanPlayer];
        const card = hand.find(c => getCardKey(c) === cardKey);
        if (card) {
          const artUrl = getCardArtUrl(card);
          if (artUrl) {
            flyingCard.innerHTML = `
              <div class="card-art" style="background-image: url(${artUrl})"></div>
              <div class="card-overlay"></div>
            `;
          }
          flyingCard.innerHTML += `
            <div class="card-content">
              <div class="card-top">
                <span class="card-owner-badge" data-owner="${card.owner}"></span>
                <span class="card-strength">${card.strength}</span>
              </div>
              <div class="card-bottom">
                <div class="card-species">${card.species}</div>
                <div class="card-points">+${card.points} pts</div>
              </div>
            </div>
          `;
        }
      }

      document.body.appendChild(flyingCard);
      await waitForAnimation(flyingCard, ANIM_TIMING.CARD_TO_QUEUE + 50);
      flyingCard.remove();

      // Remove the original card's animation class (it will be re-rendered without the card anyway)
      if (originalCard) {
        originalCard.classList.remove('animating-playing');
      }
    }

    // Animate cards being killed (sent to That's It)
    async function animateKillCards(cardKeys) {
      const animations = [];

      // First, highlight all cards being killed
      cardKeys.forEach((key) => {
        const cardEl = document.querySelector(`#queue .card[data-card-key="${key}"]`);
        if (cardEl) {
          cardEl.classList.add('highlight-kill');
        }
      });

      // Show "KILLED!" label on first card
      const firstCard = document.querySelector(`#queue .card[data-card-key="${cardKeys[0]}"]`);
      if (firstCard) {
        showLabelNearCard(firstCard, 'KILLED!', 'kill');
      }

      await delay(300); // Let highlight show

      cardKeys.forEach((key, idx) => {
        const cardEl = document.querySelector(`#queue .card[data-card-key="${key}"]`);
        if (cardEl) {
          cardEl.classList.remove('highlight-kill');
          cardEl.classList.add('animating-kill');
          if (idx > 0) cardEl.classList.add(`anim-delay-${Math.min(idx, 4)}`);
          animations.push(waitForAnimation(cardEl, ANIM_TIMING.KILL_EFFECT + idx * ANIM_TIMING.STAGGER_DELAY + 50));
        }
      });

      if (animations.length > 0) {
        await Promise.all(animations);
      }
    }

    // Animate cards scoring to Heaven's Gate
    async function animateScoreCards(cardKeys) {
      const animations = [];

      // First, highlight all cards scoring
      cardKeys.forEach((key) => {
        const cardEl = document.querySelector(`#queue .card[data-card-key="${key}"]`);
        if (cardEl) {
          cardEl.classList.add('highlight-score');
        }
      });

      // Show "SCORE!" label on first card
      const firstCard = document.querySelector(`#queue .card[data-card-key="${cardKeys[0]}"]`);
      if (firstCard) {
        showLabelNearCard(firstCard, 'SCORE!', 'score');
      }

      await delay(400); // Let highlight show longer for score

      cardKeys.forEach((key, idx) => {
        const cardEl = document.querySelector(`#queue .card[data-card-key="${key}"]`);
        if (cardEl) {
          cardEl.classList.remove('highlight-score');
          cardEl.classList.add('animating-score');
          if (idx > 0) cardEl.classList.add(`anim-delay-${Math.min(idx, 4)}`);
          animations.push(waitForAnimation(cardEl, ANIM_TIMING.SCORE_ENTRY + idx * ANIM_TIMING.STAGGER_DELAY + 50));
        }
      });

      if (animations.length > 0) {
        await Promise.all(animations);
      }
    }

    // Animate cards going to That's It pile (5-animal check)
    async function animateToHellCards(cardKeys) {
      const animations = [];

      cardKeys.forEach((key, idx) => {
        const cardEl = document.querySelector(`#queue .card[data-card-key="${key}"]`);
        if (cardEl) {
          cardEl.classList.add('animating-to-hell');
          if (idx > 0) cardEl.classList.add(`anim-delay-${Math.min(idx, 4)}`);
          animations.push(waitForAnimation(cardEl, ANIM_TIMING.HELL_ENTRY + idx * ANIM_TIMING.STAGGER_DELAY + 50));
        }
      });

      if (animations.length > 0) {
        await Promise.all(animations);
      }
    }

    // FLIP animation for queue reorder
    async function animateQueueReorder(oldPositions) {
      const queueCards = document.querySelectorAll('#queue .card');

      // Apply inverse transforms
      const toAnimate = [];
      queueCards.forEach(cardEl => {
        const key = cardEl.dataset.cardKey;
        const oldPos = oldPositions.get(key);
        if (oldPos && oldPos.container === 'queue') {
          const newRect = cardEl.getBoundingClientRect();
          const deltaX = oldPos.rect.left - newRect.left;
          const deltaY = oldPos.rect.top - newRect.top;

          if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
            cardEl.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            cardEl.style.transition = 'none';
            toAnimate.push(cardEl);
          }
        }
      });

      if (toAnimate.length === 0) return;

      // Force reflow
      document.body.offsetHeight;

      // Play animation
      await Promise.all(toAnimate.map(cardEl => {
        return new Promise(resolve => {
          cardEl.classList.add('animating-move');
          cardEl.style.transform = '';

          const handler = () => {
            cardEl.removeEventListener('transitionend', handler);
            cardEl.classList.remove('animating-move');
            cardEl.style.transition = '';
            resolve();
          };
          cardEl.addEventListener('transitionend', handler);
          setTimeout(resolve, ANIM_TIMING.QUEUE_REORDER + 50);
        });
      }));
    }

    // Flash queue for seal reversal
    async function animateQueueReversal() {
      const queue = document.getElementById('queue');

      // Show FLIP! label in center of queue
      const queueRect = queue.getBoundingClientRect();
      showAnimLabel('FLIP!', queueRect.left + queueRect.width / 2 - 30, queueRect.top + queueRect.height / 2 - 20, 'reverse');

      queue.classList.add('animating-reverse');
      await delay(600); // Longer for more drama
      queue.classList.remove('animating-reverse');
    }

    // Parse turn flow events to determine animations
    function parseAnimationEvents(oldState, newState, turnFlow) {
      const animations = [];

      if (!turnFlow || !oldState || !newState) return animations;

      // Detect played card from human (hand ‚Üí queue)
      if (playingCardKey) {
        animations.push({ type: 'card-to-queue', cardKey: playingCardKey });
      }

      // Detect AI played card by parsing the "play" step
      if (!playingCardKey) {
        const playStep = turnFlow.find(s => s.name === 'play');
        if (playStep && playStep.events) {
          for (const event of playStep.events) {
            // Match "Played [Species] (P[N]) to the queue"
            const match = event.match(/Played\s+(\w+)\s+\(P(\d)\)/i);
            if (match) {
              const species = match[1].toLowerCase();
              const player = parseInt(match[2]);
              // Find this card in the new queue
              const cardInQueue = newState.queue.find(c =>
                c.species.toLowerCase() === species && c.owner === player
              );
              if (cardInQueue) {
                animations.push({ type: 'card-appear-in-queue', cardKey: getCardKey(cardInQueue) });
              }
            }
          }
        }
      }

      // Find cards that moved to That's It (killed)
      const killedKeys = findRemovedFromQueue(oldState.queue, newState.queue, newState.zones.thatsIt);
      if (killedKeys.length > 0) {
        animations.push({ type: 'kill', cardKeys: killedKeys });
      }

      // Find cards that moved to Heaven's Gate (scored)
      const scoredKeys = findRemovedFromQueue(oldState.queue, newState.queue, newState.zones.beastyBar);
      if (scoredKeys.length > 0) {
        animations.push({ type: 'score', cardKeys: scoredKeys });
      }

      // Check for queue reorder events
      for (const step of turnFlow) {
        const events = step.events || [];
        for (const event of events) {
          const eventLower = event.toLowerCase();

          // Queue reorder (various animals)
          if (eventLower.includes('hops')) {
            animations.push({ type: 'queue-reorder', reason: 'hop', label: 'HOP!' });
          } else if (eventLower.includes('roars') || eventLower.includes('to the front')) {
            animations.push({ type: 'queue-reorder', reason: 'roar', label: 'ROAR!' });
          } else if (eventLower.includes('orders') || eventLower.includes('sorted') || eventLower.includes('rearranges')) {
            animations.push({ type: 'queue-reorder', reason: 'order', label: 'ORDER!' });
          } else if (eventLower.includes('pushes') || eventLower.includes('behind')) {
            animations.push({ type: 'queue-reorder', reason: 'push', label: 'PUSH!' });
          } else if (eventLower.includes('swaps') || eventLower.includes('switches')) {
            animations.push({ type: 'queue-reorder', reason: 'swap', label: 'SWAP!' });
          } else if (eventLower.includes('moves') || eventLower.includes('shifts')) {
            animations.push({ type: 'queue-reorder', reason: 'move', label: 'MOVE!' });
          }

          // Seal reversal
          if (eventLower.includes('flips') || eventLower.includes('reverses direction')) {
            animations.push({ type: 'queue-reverse' });
          }
        }
      }

      // Fallback: detect queue reorder by comparing positions directly
      // Only if no reorder animation was already added
      const hasReorderAnim = animations.some(a => a.type === 'queue-reorder' || a.type === 'queue-reverse');
      if (!hasReorderAnim && oldState.queue && newState.queue) {
        // Check if existing cards changed positions (excluding added/removed cards)
        const oldKeys = oldState.queue.map(getCardKey);
        const newKeys = newState.queue.map(getCardKey);

        // Find cards that exist in both queues
        const commonKeys = oldKeys.filter(k => newKeys.includes(k));

        // Check if their relative order changed
        if (commonKeys.length >= 2) {
          const oldOrder = commonKeys.map(k => oldKeys.indexOf(k));
          const newOrder = commonKeys.map(k => newKeys.indexOf(k));

          // Check if any pair is in different relative order
          let orderChanged = false;
          for (let i = 0; i < commonKeys.length - 1 && !orderChanged; i++) {
            for (let j = i + 1; j < commonKeys.length; j++) {
              const oldDiff = oldOrder[i] - oldOrder[j];
              const newDiff = newOrder[i] - newOrder[j];
              if ((oldDiff > 0 && newDiff < 0) || (oldDiff < 0 && newDiff > 0)) {
                orderChanged = true;
                break;
              }
            }
          }

          if (orderChanged) {
            console.log('[ANIM] Detected queue reorder by position comparison');
            animations.push({ type: 'queue-reorder', reason: 'move', label: 'SHUFFLE!' });
          }
        }
      }

      console.log('[ANIM] Detected killedKeys:', killedKeys);
      console.log('[ANIM] Detected scoredKeys:', scoredKeys);
      console.log('[ANIM] All animations:', animations.map(a => a.type));

      return animations;
    }

    // Helper: find cards removed from queue
    function findRemovedFromQueue(oldQueue, newQueue, targetPile) {
      if (!oldQueue || !newQueue) return [];

      const oldKeys = new Set(oldQueue.map(getCardKey));
      const newKeys = new Set(newQueue.map(getCardKey));
      const targetKeys = new Set((targetPile || []).map(getCardKey));

      const removed = [];
      oldKeys.forEach(key => {
        if (!newKeys.has(key) && targetKeys.has(key)) {
          removed.push(key);
        }
      });

      return removed;
    }

    // Helper: compare arrays
    function arraysEqual(a, b) {
      if (!a || !b || a.length !== b.length) return false;
      return a.every((v, i) => v === b[i]);
    }

    // Main animation orchestrator
    async function runAnimations(oldState, newState, turnFlow) {
      console.log('[ANIM] runAnimations called');
      console.log('[ANIM] playingCardKey:', playingCardKey);
      console.log('[ANIM] positionTracker size:', positionTracker.positions.size);

      if (isAnimating) {
        console.log('[ANIM] Already animating, skipping');
        return;
      }
      isAnimating = true;

      try {
        const animations = parseAnimationEvents(oldState, newState, turnFlow);
        console.log('[ANIM] Parsed animations:', JSON.stringify(animations));

        if (animations.length === 0) {
          console.log('[ANIM] No animations to run');
          return;
        }

        // Phase 1: Card to queue animation (human player)
        const cardToQueue = animations.find(a => a.type === 'card-to-queue');
        if (cardToQueue) {
          const sourcePos = positionTracker.getPosition(cardToQueue.cardKey);
          console.log('[ANIM] Card to queue sourcePos:', sourcePos);
          if (sourcePos) {
            await animateCardToQueue(cardToQueue.cardKey, sourcePos.rect);
          }
        }

        // Phase 2: Render intermediate state (cards in queue before kill/score)
        // We need to show cards that will be killed/scored, so render with old queue + new card
        // For simplicity, render old state to show cards that will animate out
        const hasKillOrScore = animations.some(a =>
          a.type === 'kill' || a.type === 'score' || a.type === 'to-hell'
        );

        if (hasKillOrScore) {
          // Temporarily render a state where killed/scored cards are still visible
          const tempState = JSON.parse(JSON.stringify(newState));
          // Add back the cards that were removed so we can animate them
          const killAnim = animations.find(a => a.type === 'kill');
          const scoreAnim = animations.find(a => a.type === 'score');

          if (killAnim) {
            killAnim.cardKeys.forEach(key => {
              const card = oldState.queue.find(c => getCardKey(c) === key);
              if (card && !tempState.queue.find(c => getCardKey(c) === key)) {
                tempState.queue.push(card);
              }
            });
          }
          if (scoreAnim) {
            scoreAnim.cardKeys.forEach(key => {
              const card = oldState.queue.find(c => getCardKey(c) === key);
              if (card && !tempState.queue.find(c => getCardKey(c) === key)) {
                tempState.queue.unshift(card); // Scored cards were at front
              }
            });
          }

          gameState = tempState;
          render();
          await delay(50); // Let DOM update
        }

        // Phase 3: Kill animations
        const killAnim = animations.find(a => a.type === 'kill');
        if (killAnim && killAnim.cardKeys.length > 0) {
          console.log('[ANIM] Running kill animation for:', killAnim.cardKeys);
          await animateKillCards(killAnim.cardKeys);
          await delay(ANIM_TIMING.PHASE_GAP);
        }

        // Phase 4: Score animations
        const scoreAnim = animations.find(a => a.type === 'score');
        if (scoreAnim && scoreAnim.cardKeys.length > 0) {
          console.log('[ANIM] Running score animation for:', scoreAnim.cardKeys);
          await animateScoreCards(scoreAnim.cardKeys);
          await delay(ANIM_TIMING.PHASE_GAP);
        }

        // Phase 5: Queue reorder (FLIP animation)
        const reorderAnim = animations.find(a => a.type === 'queue-reorder');
        if (reorderAnim) {
          console.log('[ANIM] Running queue reorder animation', reorderAnim.reason);

          // Step 1: Show intermediate state (card at end of queue before hop)
          // Build intermediate queue: new cards at end, old order preserved
          const intermediateState = JSON.parse(JSON.stringify(newState));

          // Get cards that are new to queue (just played)
          const oldQueueKeys = new Set(oldState.queue.map(getCardKey));
          const newCards = newState.queue.filter(c => !oldQueueKeys.has(getCardKey(c)));
          const existingCards = newState.queue.filter(c => oldQueueKeys.has(getCardKey(c)));

          // Reconstruct with old order for existing cards, new cards at end
          const orderedExisting = oldState.queue.filter(c =>
            existingCards.some(nc => getCardKey(nc) === getCardKey(c))
          );
          intermediateState.queue = [...orderedExisting, ...newCards];

          // Render intermediate state
          gameState = intermediateState;
          render();
          await delay(200);

          // Find the card that's moving most (either new card or card that changed position most)
          let movingCardKey = null;
          let movingCardEl = null;

          if (newCards.length > 0) {
            // New card is moving
            movingCardKey = getCardKey(newCards[0]);
            movingCardEl = document.querySelector(`#queue .card[data-card-key="${movingCardKey}"]`);
          } else {
            // No new cards - find card that moved the most by comparing indices
            const oldQueueKeysList = oldState.queue.map(getCardKey);
            const newQueueKeysList = newState.queue.map(getCardKey);

            let maxMove = 0;
            existingCards.forEach(card => {
              const key = getCardKey(card);
              const oldIdx = oldQueueKeysList.indexOf(key);
              const newIdx = newQueueKeysList.indexOf(key);
              const move = Math.abs(newIdx - oldIdx);
              if (move > maxMove) {
                maxMove = move;
                movingCardKey = key;
              }
            });

            if (movingCardKey) {
              movingCardEl = document.querySelector(`#queue .card[data-card-key="${movingCardKey}"]`);
            }
          }

          // Show label and highlight on the moving card
          if (movingCardEl && reorderAnim.label) {
            movingCardEl.classList.add('highlight-target');
            showLabelNearCard(movingCardEl, reorderAnim.label, reorderAnim.reason);

            // Add specific animation based on reason
            if (reorderAnim.reason === 'hop') {
              movingCardEl.classList.add('animating-hop');
              await delay(500);
              movingCardEl.classList.remove('animating-hop');
            } else if (reorderAnim.reason === 'push') {
              movingCardEl.classList.add('animating-push');
              await delay(400);
              movingCardEl.classList.remove('animating-push');
            } else if (reorderAnim.reason === 'roar') {
              movingCardEl.classList.add('animating-roar');
              await delay(450);
              movingCardEl.classList.remove('animating-roar');
            }
          }

          await delay(300); // Let label show

          // Step 2: Capture positions before reorder
          const beforePositions = new Map();
          document.querySelectorAll('#queue .card').forEach(el => {
            const key = el.dataset.cardKey;
            if (key) {
              beforePositions.set(key, el.getBoundingClientRect());
            }
          });

          // Remove highlights
          document.querySelectorAll('#queue .card.highlight-target').forEach(el => {
            el.classList.remove('highlight-target');
          });

          // Step 3: Render final state
          gameState = newState;
          render();
          await delay(50);

          // Step 4: Calculate deltas and apply inverse transforms
          const cardsToAnimate = [];
          document.querySelectorAll('#queue .card').forEach(el => {
            const key = el.dataset.cardKey;
            const oldRect = beforePositions.get(key);
            if (oldRect) {
              const newRect = el.getBoundingClientRect();
              const deltaX = oldRect.left - newRect.left;
              const deltaY = oldRect.top - newRect.top;

              if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                el.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                el.style.transition = 'none';
                el.style.zIndex = '100';
                cardsToAnimate.push(el);
              }
            }
          });

          if (cardsToAnimate.length > 0) {
            // Force reflow
            document.body.offsetHeight;

            // Step 5: Animate to final positions
            await Promise.all(cardsToAnimate.map(el => {
              return new Promise(resolve => {
                el.style.transition = `transform ${ANIM_TIMING.QUEUE_REORDER}ms var(--anim-bounce)`;
                el.style.transform = '';

                setTimeout(() => {
                  el.style.transition = '';
                  el.style.zIndex = '';
                  resolve();
                }, ANIM_TIMING.QUEUE_REORDER + 50);
              });
            }));
          }

          await delay(ANIM_TIMING.PHASE_GAP);
        }

        // Phase 6: Queue reversal
        const reverseAnim = animations.find(a => a.type === 'queue-reverse');
        if (reverseAnim) {
          console.log('[ANIM] Running queue reverse animation');
          await animateQueueReversal();
        }

        // Phase 7: AI card appear animation
        const appearAnim = animations.find(a => a.type === 'card-appear-in-queue');
        if (appearAnim) {
          console.log('[ANIM] Running card appear animation');
          gameState = newState;
          render();
          await delay(50);
          const cardEl = document.querySelector(`#queue .card[data-card-key="${appearAnim.cardKey}"]`);
          if (cardEl) {
            cardEl.classList.add('animating-appear');
            await delay(ANIM_TIMING.CARD_TO_QUEUE);
            cardEl.classList.remove('animating-appear');
          }
        }

      } finally {
        isAnimating = false;
        playingCardKey = null;
        positionTracker.clear();
      }
    }

    // Simple flash effect for queue reorder
    async function animateQueueFlash() {
      const queue = document.getElementById('queue');
      queue.style.transition = 'box-shadow 150ms ease-out';
      queue.style.boxShadow = '0 0 20px var(--warning)';
      await delay(150);
      queue.style.boxShadow = '';
      await delay(150);
      queue.style.transition = '';
    }

    // Clear any active animations
    function clearAnimations() {
      isAnimating = false;
      playingCardKey = null;
      document.querySelectorAll('[class*="animating-"]').forEach(el => {
        el.className = el.className.replace(/\banimating-\S+/g, '').trim();
        el.style.transform = '';
        el.style.transition = '';
      });
    }

    // ===================== End Animation System =====================

    // Elements
    const turnBadge = document.getElementById('turn-badge');
    const turnText = document.getElementById('turn-text');
    const scoreLabels = [document.getElementById('score-label-0'), document.getElementById('score-label-1')];
    const scoreValues = [document.getElementById('score-0'), document.getElementById('score-1')];
    const scoreItems = document.querySelectorAll('.score-item');
    const aiMoveBtn = document.getElementById('ai-move-btn');
    const newGameBtn = document.getElementById('new-game-btn');
    const queueEl = document.getElementById('queue');
    const handEl = document.getElementById('hand');
    const heavenCards = document.getElementById('heaven-cards');
    const heavenCount = document.getElementById('heaven-count');
    const hellCards = document.getElementById('hell-cards');
    const hellCount = document.getElementById('hell-count');
    const hintEl = document.getElementById('hint');
    const gameOverEl = document.getElementById('game-over');
    const gameOverTitle = document.getElementById('game-over-title');
    const gameOverScore = document.getElementById('game-over-score');
    const playAgainBtn = document.getElementById('play-again-btn');
    const modalOverlay = document.getElementById('new-game-modal');
    const aiSelect = document.getElementById('ai-select');
    const playerSelect = document.getElementById('player-select');
    const seedInput = document.getElementById('seed-input');
    const cancelModalBtn = document.getElementById('cancel-modal');
    const startGameBtn = document.getElementById('start-game');

    // Claude modal elements
    const claudeModal = document.getElementById('claude-modal');
    const claudeStateEl = document.getElementById('claude-state');
    const copyStateBtn = document.getElementById('copy-state-btn');
    const claudeMoveInput = document.getElementById('claude-move-input');
    const submitClaudeMoveBtn = document.getElementById('submit-claude-move');

    // Stats modal elements
    const statsBtn = document.getElementById('stats-btn');
    const statsModal = document.getElementById('stats-modal');
    const statsTableBody = document.getElementById('stats-table-body');
    const statsEmpty = document.getElementById('stats-empty');
    const statsClearBtn = document.getElementById('stats-clear-btn');
    const statsCloseBtn = document.getElementById('stats-close-btn');

    // ===================== Stats Tracking =====================
    let cachedStats = {};

    async function loadStats() {
      try {
        const res = await fetch('/api/stats');
        if (res.ok) {
          cachedStats = await res.json();
        }
      } catch (err) {
        console.error('Failed to load stats:', err);
      }
      return cachedStats;
    }

    async function saveStats(stats) {
      try {
        await fetch('/api/stats', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(stats)
        });
        cachedStats = stats;
      } catch (err) {
        console.error('Failed to save stats:', err);
      }
    }

    async function recordGameResult(opponentId, opponentName, result) {
      // result: 'win', 'loss', or 'draw'
      const stats = await loadStats();
      if (!stats[opponentId]) {
        stats[opponentId] = { name: opponentName, wins: 0, losses: 0, draws: 0 };
      }
      stats[opponentId].name = opponentName; // Update name in case it changed
      if (result === 'win') stats[opponentId].wins++;
      else if (result === 'loss') stats[opponentId].losses++;
      else stats[opponentId].draws++;
      await saveStats(stats);
    }

    async function renderStats() {
      const stats = await loadStats();
      const opponents = Object.entries(stats);

      if (opponents.length === 0) {
        statsTableBody.innerHTML = '';
        statsEmpty.style.display = 'block';
        return;
      }

      statsEmpty.style.display = 'none';

      // Sort by total games played (descending)
      opponents.sort((a, b) => {
        const totalA = a[1].wins + a[1].losses + a[1].draws;
        const totalB = b[1].wins + b[1].losses + b[1].draws;
        return totalB - totalA;
      });

      let totalWins = 0, totalLosses = 0, totalDraws = 0;

      let html = '';
      for (const [id, data] of opponents) {
        const total = data.wins + data.losses + data.draws;
        const winRate = total > 0 ? Math.round((data.wins / total) * 100) : 0;
        const rateClass = winRate >= 50 ? 'good' : winRate >= 30 ? 'neutral' : 'bad';

        totalWins += data.wins;
        totalLosses += data.losses;
        totalDraws += data.draws;

        html += `
          <tr>
            <td>${data.name}</td>
            <td>${data.wins}</td>
            <td>${data.losses}</td>
            <td>${data.draws}</td>
            <td class="win-rate ${rateClass}">${winRate}%</td>
          </tr>
        `;
      }

      // Add total row
      const totalGames = totalWins + totalLosses + totalDraws;
      const overallWinRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
      const overallRateClass = overallWinRate >= 50 ? 'good' : overallWinRate >= 30 ? 'neutral' : 'bad';

      html += `
        <tr class="stats-total-row">
          <td>TOTAL</td>
          <td>${totalWins}</td>
          <td>${totalLosses}</td>
          <td>${totalDraws}</td>
          <td class="win-rate ${overallRateClass}">${overallWinRate}%</td>
        </tr>
      `;

      statsTableBody.innerHTML = html;
    }

    async function openStatsModal() {
      await renderStats();
      statsModal.classList.add('visible');
    }

    function closeStatsModal() {
      statsModal.classList.remove('visible');
    }

    // Stats event listeners
    statsBtn.addEventListener('click', openStatsModal);
    statsCloseBtn.addEventListener('click', closeStatsModal);
    statsClearBtn.addEventListener('click', async () => {
      if (confirm('Are you sure you want to clear all stats? This cannot be undone.')) {
        try {
          await fetch('/api/stats', { method: 'DELETE' });
          cachedStats = {};
          await renderStats();
        } catch (err) {
          console.error('Failed to clear stats:', err);
        }
      }
    });
    statsModal.addEventListener('click', (e) => {
      if (e.target === statsModal) closeStatsModal();
    });

    // Card Art
    const CARD_ART_PATH = '/static/cards';

    function getCardArtUrl(card) {
      if (!card || typeof card.owner !== 'number' || typeof card.strength !== 'number') return null;
      if (card.species === 'unknown') return null;
      return `${CARD_ART_PATH}/${card.owner}${card.strength}.jpg`;
    }

    // Event Listeners
    newGameBtn.addEventListener('click', showModal);
    playAgainBtn.addEventListener('click', showModal);
    cancelModalBtn.addEventListener('click', hideModal);
    startGameBtn.addEventListener('click', startNewGame);
    aiMoveBtn.addEventListener('click', makeAiMove);

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) hideModal();
    });

    // Claude modal events
    copyStateBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(claudeStateEl.value);
        copyStateBtn.textContent = 'Copied!';
        setTimeout(() => { copyStateBtn.textContent = 'Copy to Clipboard'; }, 2000);
      } catch (err) {
        claudeStateEl.select();
      }
    });

    submitClaudeMoveBtn.addEventListener('click', submitClaudeMove);
    claudeMoveInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') submitClaudeMove();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (modalOverlay.classList.contains('visible')) {
          hideModal();
        } else if (pendingSelection) {
          clearSelection();
        }
      }
    });

    async function loadAgents() {
      try {
        const res = await fetch('/api/ai-agents');
        if (res.ok) {
          const agents = await res.json();
          aiSelect.innerHTML = '';
          agents.forEach(agent => {
            const opt = document.createElement('option');
            opt.value = agent.id;
            opt.textContent = agent.name;
            aiSelect.appendChild(opt);
          });
        }
      } catch (err) {
        console.error('Failed to load agents:', err);
      }
    }

    function showModal() {
      // Don't show new-game modal if splash screen is still visible
      const splash = document.getElementById('splash-overlay');
      if (splash && !splash.classList.contains('hidden')) return;
      loadAgents();
      modalOverlay.classList.add('visible');
    }

    function hideModal() {
      modalOverlay.classList.remove('visible');
    }

    async function startNewGame() {
      const payload = {
        humanPlayer: parseInt(playerSelect.value),
        startingPlayer: 0,
        aiOpponent: aiSelect.value
      };

      const seed = seedInput.value.trim();
      if (seed && !isNaN(parseInt(seed))) {
        payload.seed = parseInt(seed);
      }

      try {
        const res = await fetch('/api/new-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (res.ok) {
          // Track current opponent for stats
          currentOpponentId = aiSelect.value;
          currentOpponentName = aiSelect.options[aiSelect.selectedIndex].text;
          gameResultRecorded = false;

          hideModal();
          await refreshState();
        }
      } catch (err) {
        console.error('Failed to start game:', err);
      }
    }

    async function makeAiMove() {
      // Clear any pending timeout
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      aiMoveBtn.disabled = true;
      aiMoveBtn.textContent = 'AI Moving...';

      // Capture state and positions for animations
      previousGameState = gameState ? JSON.parse(JSON.stringify(gameState)) : null;
      positionTracker.captureAll();

      try {
        const res = await fetch('/api/ai-move', { method: 'POST' });
        if (res.ok) {
          await refreshStateWithAnimations();
        } else {
          clearAnimations();
          await refreshState();
        }
      } catch (err) {
        console.error('AI move failed:', err);
        clearAnimations();
        aiMoveBtn.disabled = false;
        aiMoveBtn.textContent = 'AI Move';
      }
    }

    async function showClaudeModal() {
      try {
        const res = await fetch('/api/claude-state');
        if (res.ok) {
          const data = await res.json();
          claudeStateEl.value = data.formatted;
          claudeMoveInput.value = '';
          claudeModal.classList.add('visible');
        }
      } catch (err) {
        console.error('Failed to get Claude state:', err);
      }
    }

    function hideClaudeModal() {
      claudeModal.classList.remove('visible');
    }

    async function submitClaudeMove() {
      const input = claudeMoveInput.value.trim();
      const actionIndex = parseInt(input);

      if (isNaN(actionIndex) || actionIndex < 1) {
        alert('Please enter a valid action number');
        return;
      }

      submitClaudeMoveBtn.disabled = true;
      submitClaudeMoveBtn.textContent = 'Applying...';

      try {
        const res = await fetch('/api/claude-move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ actionIndex })
        });

        if (res.ok) {
          hideClaudeModal();
          await refreshState();
        } else {
          const err = await res.json();
          alert(err.detail || 'Invalid move');
        }
      } catch (err) {
        console.error('Claude move failed:', err);
        alert('Failed to submit move');
      } finally {
        submitClaudeMoveBtn.disabled = false;
        submitClaudeMoveBtn.textContent = 'Submit Move';
      }
    }

    // Claude Bridge - Automated file-based communication
    let claudePollingInterval = null;

    async function startClaudeBridge() {
      // Don't start if already polling
      if (claudePollingInterval) return;

      // Write state to file for Claude Code to read
      try {
        const res = await fetch('/api/claude-bridge/write-state', { method: 'POST' });
        const data = await res.json();

        if (data.written) {
          // Start polling for Claude's response
          claudePollingInterval = setInterval(checkClaudeResponse, 1000);
        }
      } catch (err) {
        console.error('Failed to write Claude state:', err);
      }
    }

    function stopClaudePolling() {
      if (claudePollingInterval) {
        clearInterval(claudePollingInterval);
        claudePollingInterval = null;
      }
    }

    async function checkClaudeResponse() {
      try {
        const res = await fetch('/api/claude-bridge/check-move');
        const data = await res.json();

        if (data.hasMove) {
          stopClaudePolling();

          // Apply Claude's move
          const applyRes = await fetch('/api/claude-bridge/apply-move', { method: 'POST' });
          if (applyRes.ok) {
            await refreshState();
          } else {
            const err = await applyRes.json();
            console.error('Failed to apply Claude move:', err.detail);
          }
        }
      } catch (err) {
        console.error('Error checking Claude response:', err);
      }
    }

    async function refreshState() {
      try {
        const res = await fetch('/api/state');
        if (res.ok) {
          gameState = await res.json();
          render();
        } else {
          // No active game - show new game modal
          gameState = null;
          showModal();
        }
      } catch (err) {
        if (isFirstLoad) showModal();
      }
      isFirstLoad = false;
    }

    function render() {
      if (!gameState) return;

      const { activePlayer, humanPlayer, isTerminal, score, zones, queue, hands, isAiTurn } = gameState;
      const legalActions = gameState.legalActions || [];
      const isYourTurn = activePlayer === humanPlayer;

      // Scores
      const runningScore = [0, 0];
      zones.beastyBar.forEach(c => { runningScore[c.owner] += c.points; });
      const displayScore = isTerminal && score ? score : runningScore;

      const opponentName = gameState.aiOpponent === 'claude' ? 'Claude' : 'AI';
      scoreLabels[humanPlayer].textContent = 'You';
      scoreLabels[1 - humanPlayer].textContent = opponentName;
      scoreValues[0].textContent = displayScore[0];
      scoreValues[1].textContent = displayScore[1];

      scoreItems.forEach(el => el.classList.remove('active'));
      if (!isTerminal) {
        scoreItems[activePlayer].classList.add('active');
      }

      // Turn Badge
      turnBadge.classList.remove('your-turn', 'ai-turn');
      if (isTerminal) {
        turnText.textContent = 'Game Over';
      } else if (isYourTurn) {
        turnBadge.classList.add('your-turn');
        turnText.textContent = 'Your Turn';
      } else {
        turnBadge.classList.add('ai-turn');
        turnText.textContent = gameState.aiOpponent === 'claude' ? 'Claude\'s Turn' : 'AI Turn';
      }

      // AI/Claude turn handling
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }

      const isClaudeOpponent = gameState.aiOpponent === 'claude';

      if (isAiTurn && !isTerminal) {
        // All AI opponents (including Claude) use the same flow
        aiMoveBtn.style.display = 'flex';
        aiMoveBtn.textContent = isClaudeOpponent ? 'Claude Thinking...' : 'AI Thinking...';
        aiMoveBtn.disabled = true;
        aiMoveBtn.classList.toggle('btn-ai', !isClaudeOpponent);
        aiMoveBtn.classList.toggle('btn-primary', isClaudeOpponent);

        aiMoveTimeout = setTimeout(() => {
          makeAiMove();
        }, isClaudeOpponent ? 500 : 2000);
      } else {
        aiMoveBtn.style.display = 'none';
      }

      // Piles
      renderPile(heavenCards, heavenCount, zones.beastyBar);
      renderPile(hellCards, hellCount, zones.thatsIt);

      // Queue
      renderQueue(queue, legalActions);

      // Hand
      renderHand(hands[humanPlayer], legalActions, isYourTurn && !isTerminal);

      // Hint
      updateHint(isYourTurn, isTerminal);

      // Game Over
      if (isTerminal) {
        showGameOver(displayScore, humanPlayer);
      } else {
        gameOverEl.classList.remove('visible');
      }
    }

    function renderPile(container, countEl, cards) {
      countEl.textContent = cards.length;
      container.innerHTML = '';

      if (!cards.length) {
        container.innerHTML = '<div class="pile-empty">Empty</div>';
        return;
      }

      [...cards].reverse().forEach(card => {
        const el = document.createElement('div');
        el.className = 'pile-card';
        el.innerHTML = `
          <span class="pile-card-owner" data-owner="${card.owner}"></span>
          <span class="pile-card-name">${card.species}</span>
          <span class="pile-card-pts">+${card.points}</span>
        `;
        container.appendChild(el);
      });
    }

    function renderQueue(cards, legalActions) {
      const targeting = pendingSelection && ['target', 'chameleon-extra'].includes(pendingSelection.type);
      queueEl.classList.toggle('targeting', targeting);
      queueEl.innerHTML = '';

      if (!cards.length) {
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.className = 'queue-slot';
          slot.textContent = i + 1;
          queueEl.appendChild(slot);
        }
        return;
      }

      const targetIndices = getTargetableIndices();

      cards.forEach((card, idx) => {
        const isTargetable = targetIndices.has(idx);
        const isDimmed = targeting && !isTargetable;
        const el = createCardElement(card, {
          targetable: isTargetable,
          dimmed: isDimmed,
          onClick: isTargetable ? () => handleQueueClick(idx) : null
        });
        queueEl.appendChild(el);
      });
    }

    function renderHand(cards, legalActions, canPlay) {
      handEl.innerHTML = '';

      if (!cards.length) {
        handEl.innerHTML = '<div class="hand-empty">No cards in hand</div>';
        return;
      }

      const actionsByHand = new Map();
      legalActions.forEach(a => {
        if (!actionsByHand.has(a.handIndex)) actionsByHand.set(a.handIndex, []);
        actionsByHand.get(a.handIndex).push(a);
      });

      cards.forEach((card, idx) => {
        const actions = actionsByHand.get(idx) || [];
        const isPlayable = canPlay && actions.length > 0;

        const isSelected = pendingSelection?.handIndex === idx;

        let inlineOptions = null;
        if (isSelected) {
          if (pendingSelection.type === 'kangaroo') {
            inlineOptions = pendingSelection.actions.map(a => ({
              label: a.params[0] === 0 ? 'Stay' : `Hop ${a.params[0]}`,
              action: a
            }));
          } else if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'kangaroo') {
            inlineOptions = pendingSelection.actions
              .filter(a => a.params.length > 1)
              .map(a => ({
                label: a.params[1] === 0 ? 'Stay' : `Hop ${a.params[1]}`,
                action: a
              }));
          }
        }

        const el = createCardElement(card, {
          isHandCard: true,
          playable: isPlayable && !pendingSelection,
          selected: isSelected,
          disabled: canPlay && !isPlayable && !isSelected,
          onClick: isPlayable ? () => handleHandClick(card, idx, actions) : null,
          inlineOptions
        });
        handEl.appendChild(el);
      });
    }

    function createCardElement(card, opts = {}) {
      const { isHandCard, playable, selected, targetable, dimmed, disabled, onClick, inlineOptions } = opts;

      const el = document.createElement('div');
      el.className = 'card';
      el.dataset.cardKey = getCardKey(card); // For animation tracking
      if (isHandCard) el.classList.add('hand-card');
      if (playable) el.classList.add('playable');
      if (selected) el.classList.add('selected');
      if (targetable) el.classList.add('targetable');
      if (dimmed) el.classList.add('dimmed');
      if (disabled) el.classList.add('disabled');

      const artUrl = getCardArtUrl(card);
      if (artUrl) {
        el.innerHTML = `
          <div class="card-art" style="background-image: url(${artUrl})"></div>
          <div class="card-overlay"></div>
        `;
      } else {
        el.classList.add('no-art');
      }

      const content = document.createElement('div');
      content.className = 'card-content';
      content.innerHTML = `
        <div class="card-top">
          <span class="card-owner-badge" data-owner="${card.owner}"></span>
          <span class="card-strength">${card.strength}</span>
        </div>
        <div class="card-bottom">
          <div class="card-species">${card.species}</div>
          <div class="card-points">+${card.points} pts</div>
        </div>
      `;
      el.appendChild(content);

      if (inlineOptions && inlineOptions.length) {
        const actionsEl = document.createElement('div');
        actionsEl.className = 'card-actions';
        inlineOptions.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'card-action-btn';
          btn.textContent = opt.label;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            sendAction(opt.action);
          });
          actionsEl.appendChild(btn);
        });
        el.appendChild(actionsEl);
      }

      if (onClick) {
        el.addEventListener('click', onClick);
      }

      return el;
    }

    function getTargetableIndices() {
      if (!pendingSelection) return new Set();

      if (pendingSelection.type === 'target') {
        return new Set(pendingSelection.actions.map(a => a.params?.[0]).filter(i => i !== undefined));
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        return new Set(pendingSelection.actions.map(a => a.params?.[1]).filter(i => i !== undefined));
      }

      return new Set();
    }

    function handleHandClick(card, idx, actions) {
      if (pendingSelection?.handIndex === idx) {
        clearSelection();
        return;
      }

      const species = card.species;

      if (species === 'parrot' || species === 'chameleon') {
        setSelection({ type: 'target', species, handIndex: idx, actions });
        return;
      }

      if (species === 'kangaroo') {
        const hops = new Set(actions.map(a => a.params?.[0]));
        if (hops.size > 1) {
          setSelection({ type: 'kangaroo', species, handIndex: idx, actions });
          return;
        }
      }

      sendAction(actions[0]);
    }

    function handleQueueClick(queueIdx) {
      if (!pendingSelection) return;

      if (pendingSelection.type === 'target') {
        const matches = pendingSelection.actions.filter(a => a.params?.[0] === queueIdx);
        if (!matches.length) return;

        if (pendingSelection.species === 'chameleon' && matches.some(a => a.params.length > 1)) {
          const targetCard = gameState?.queue?.[queueIdx];
          setSelection({
            type: 'chameleon-extra',
            species: 'chameleon',
            copiedSpecies: targetCard?.species,
            handIndex: pendingSelection.handIndex,
            actions: matches
          });
          return;
        }

        sendAction(matches[0]);
        return;
      }

      if (pendingSelection.type === 'chameleon-extra' && pendingSelection.copiedSpecies === 'parrot') {
        const matches = pendingSelection.actions.filter(a => a.params?.[1] === queueIdx);
        if (matches.length) sendAction(matches[0]);
      }
    }

    function setSelection(sel) {
      pendingSelection = sel;
      render();
    }

    function clearSelection() {
      pendingSelection = null;
      render();
    }

    async function sendAction(action) {
      // Prevent actions during animations to avoid corrupted state
      if (isAnimating) {
        console.log('[ACTION] Blocked - animation in progress');
        return;
      }

      pendingSelection = null;

      // Capture state and positions BEFORE action for animations
      previousGameState = gameState ? JSON.parse(JSON.stringify(gameState)) : null;
      positionTracker.captureAll();

      // Determine which card is being played (for hand ‚Üí queue animation)
      const playedSpecies = action.card?.species || action.species;
      if (playedSpecies && gameState) {
        const humanPlayer = gameState.humanPlayer;
        const hand = gameState.hands[humanPlayer];
        const playedCard = hand.find(c => c.species === playedSpecies);
        if (playedCard) {
          playingCardKey = getCardKey(playedCard);
          console.log('[ANIM] Set playingCardKey:', playingCardKey);
        }
      }

      // Visual feedback will be handled during animations
      // We don't mark here to avoid the fade completing before animations start

      try {
        const res = await fetch('/api/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(action)
        });
        if (!res.ok) {
          console.error('Action failed:', res.status);
          clearAnimations();
          await refreshState();
          return;
        }
        await refreshStateWithAnimations();
      } catch (err) {
        console.error('Action failed:', err);
        clearAnimations();
        await refreshState();
      }
    }

    // Refresh state with animation support
    async function refreshStateWithAnimations() {
      try {
        const res = await fetch('/api/state');
        if (!res.ok) {
          gameState = null;
          showModal();
          return;
        }

        const newState = await res.json();
        const turnFlow = newState.turnFlow || [];

        // Run animations if we have previous state
        if (previousGameState && turnFlow.length > 0) {
          gameState = newState;
          await runAnimations(previousGameState, newState, turnFlow);
        }

        // Final render with new state
        gameState = newState;
        previousGameState = null;
        render();
      } catch (err) {
        console.error('Refresh failed:', err);
        previousGameState = null;
        clearAnimations();
      }
    }

    function updateHint(isYourTurn, isTerminal) {
      hintEl.classList.remove('action-hint');

      if (isTerminal) {
        hintEl.textContent = 'Game finished. Click "New Game" to play again.';
        return;
      }

      if (!isYourTurn) {
        hintEl.textContent = gameState?.aiOpponent === 'claude'
          ? 'Claude is thinking...'
          : 'AI is thinking...';
        return;
      }

      if (pendingSelection) {
        hintEl.classList.add('action-hint');
        switch (pendingSelection.type) {
          case 'target':
            if (pendingSelection.species === 'parrot') {
              hintEl.textContent = 'Select a card in the queue to remove';
            } else if (pendingSelection.species === 'chameleon') {
              hintEl.textContent = 'Select a card in the queue to copy its ability';
            }
            break;
          case 'chameleon-extra':
            if (pendingSelection.copiedSpecies === 'parrot') {
              hintEl.textContent = 'Select which card the copied parrot should remove';
            } else if (pendingSelection.copiedSpecies === 'kangaroo') {
              hintEl.textContent = 'Choose how far to hop';
            }
            break;
          case 'kangaroo':
            hintEl.textContent = 'Choose how far to hop';
            break;
        }
        return;
      }

      hintEl.textContent = 'Select a card from your hand to play';
    }

    function showGameOver(scores, humanPlayer) {
      gameOverEl.classList.add('visible');

      const humanScore = scores[humanPlayer];
      const aiScore = scores[1 - humanPlayer];

      gameOverTitle.classList.remove('win', 'lose', 'draw');

      let result;
      if (humanScore > aiScore) {
        gameOverTitle.textContent = 'Victory!';
        gameOverTitle.classList.add('win');
        result = 'win';
      } else if (humanScore < aiScore) {
        gameOverTitle.textContent = 'Defeat';
        gameOverTitle.classList.add('lose');
        result = 'loss';
      } else {
        gameOverTitle.textContent = 'Draw';
        gameOverTitle.classList.add('draw');
        result = 'draw';
      }

      gameOverScore.textContent = `${humanScore} - ${aiScore}`;

      // Record stats (only once per game)
      if (!gameResultRecorded && currentOpponentId && currentOpponentName) {
        recordGameResult(currentOpponentId, currentOpponentName, result);
        gameResultRecorded = true;
      }
    }

    // ===================== AI Battle Mode =====================

    // Battle state
    let battleData = null;
    let battleState = 'idle'; // idle, loading, playing, paused, complete
    let battleGameIndex = 0;
    let battleTurnIndex = 0;
    let battleWins = [0, 0];
    let battlePlaybackTimer = null;
    let battleSpeed = 200; // ms per turn

    // Battle elements
    const aiBattleBtn = document.getElementById('ai-battle-btn');
    const battleWrapper = document.getElementById('battle-wrapper');
    const battleModal = document.getElementById('battle-modal');
    const battleP1Select = document.getElementById('battle-p1-select');
    const battleP2Select = document.getElementById('battle-p2-select');
    const battleGamesInput = document.getElementById('battle-games-input');
    const battleCancelBtn = document.getElementById('battle-cancel');
    const battleStartBtn = document.getElementById('battle-start');
    const battlePlayBtn = document.getElementById('battle-play-btn');
    const battleSpeedSlider = document.getElementById('battle-speed-slider');
    const battleSpeedValue = document.getElementById('battle-speed-value');
    const battleExitBtn = document.getElementById('battle-exit-btn');

    // Battle display elements
    const battleMatchup = document.getElementById('battle-matchup');
    const battleP0Name = document.getElementById('battle-p0-name');
    const battleP1Name = document.getElementById('battle-p1-name');
    const battleP0Wins = document.getElementById('battle-p0-wins');
    const battleP1Wins = document.getElementById('battle-p1-wins');
    const battleProgressFill = document.getElementById('battle-progress-fill');
    const battleProgressText = document.getElementById('battle-progress-text');
    const battleWinrateP0 = document.getElementById('battle-winrate-p0');
    const battleWinrateP1 = document.getElementById('battle-winrate-p1');
    const battleWinrateP0Pct = document.getElementById('battle-winrate-p0-pct');
    const battleWinrateP1Pct = document.getElementById('battle-winrate-p1-pct');
    const battleHandLabel0 = document.getElementById('battle-hand-label-0');
    const battleHandLabel1 = document.getElementById('battle-hand-label-1');
    const battleHandCards0 = document.getElementById('battle-hand-cards-0');
    const battleHandCards1 = document.getElementById('battle-hand-cards-1');
    const battleHand0 = document.getElementById('battle-hand-0');
    const battleHand1 = document.getElementById('battle-hand-1');
    const battleQueue = document.getElementById('battle-queue');
    const battleHeavenCards = document.getElementById('battle-heaven-cards');
    const battleHeavenCount = document.getElementById('battle-heaven-count');
    const battleHellCards = document.getElementById('battle-hell-cards');
    const battleHellCount = document.getElementById('battle-hell-count');

    // Loading overlay elements
    const battleLoadingOverlay = document.getElementById('battle-loading-overlay');
    const battleLoadingTitle = document.getElementById('battle-loading-title');
    const battleLoadingSubtitle = document.getElementById('battle-loading-subtitle');
    const battleLoadingEta = document.getElementById('battle-loading-eta');

    // ETA estimation based on agent IDs (ms per game)
    // Estimates are conservative (better to overestimate than underestimate)
    function estimateGameTime(agentId1, agentId2) {
      function isNeural(id) {
        return id.includes('ppo') || id.includes('neural') || id.includes('iter');
      }
      const neural1 = isNeural(agentId1);
      const neural2 = isNeural(agentId2);

      // Both neural: ~600ms/game
      if (neural1 && neural2) return 600;
      // One neural: ~600ms/game (neural inference dominates)
      if (neural1 || neural2) return 600;
      // Heuristic vs Heuristic: ~20ms/game
      if (agentId1 === 'heuristic' && agentId2 === 'heuristic') return 20;
      // Heuristic vs Random or Random vs Random: ~10ms/game
      return 10;
    }

    function formatEta(ms) {
      if (ms < 1000) return 'less than 1 second';
      const seconds = Math.ceil(ms / 1000);
      if (seconds < 60) return `~${seconds} second${seconds > 1 ? 's' : ''}`;
      const minutes = Math.ceil(seconds / 60);
      return `~${minutes} minute${minutes > 1 ? 's' : ''}`;
    }

    function showBattleLoading(numGames, agentId1, agentId2, displayName1, displayName2) {
      const msPerGame = estimateGameTime(agentId1, agentId2);
      const totalMs = numGames * msPerGame;

      battleLoadingTitle.textContent = `Computing ${numGames} games...`;
      battleLoadingSubtitle.textContent = `${displayName1} vs ${displayName2}`;
      battleLoadingEta.textContent = `Estimated: ${formatEta(totalMs)}`;
      battleLoadingOverlay.classList.add('visible');
    }

    function hideBattleLoading() {
      battleLoadingOverlay.classList.remove('visible');
    }

    // Load available agents for battle
    async function loadBattleAgents() {
      try {
        const res = await fetch('/api/ai-agents/battle');
        if (res.ok) {
          const agents = await res.json();
          battleP1Select.innerHTML = '';
          battleP2Select.innerHTML = '';
          agents.forEach((agent, idx) => {
            const opt1 = document.createElement('option');
            opt1.value = agent.id;
            opt1.textContent = agent.name;
            battleP1Select.appendChild(opt1);

            const opt2 = document.createElement('option');
            opt2.value = agent.id;
            opt2.textContent = agent.name;
            battleP2Select.appendChild(opt2);
          });
          // Set different defaults
          if (agents.length > 1) {
            battleP2Select.selectedIndex = 1;
          }
        }
      } catch (err) {
        console.error('Failed to load battle agents:', err);
      }
    }

    // Show battle modal
    function showBattleModal() {
      loadBattleAgents();
      battleModal.classList.add('visible');
    }

    function hideBattleModal() {
      battleModal.classList.remove('visible');
    }

    // Enter battle mode
    function enterBattleMode() {
      document.body.classList.add('battle-mode');
      battleWrapper.classList.add('active');
    }

    // Exit battle mode
    function exitBattleMode() {
      stopBattlePlayback();
      document.body.classList.remove('battle-mode');
      battleWrapper.classList.remove('active');
      battleData = null;
      battleState = 'idle';
      battleGameIndex = 0;
      battleTurnIndex = 0;
      battleWins = [0, 0];
    }

    // Start battle
    async function startBattle() {
      const p1Agent = battleP1Select.value;
      const p2Agent = battleP2Select.value;
      const p1Name = battleP1Select.options[battleP1Select.selectedIndex].text;
      const p2Name = battleP2Select.options[battleP2Select.selectedIndex].text;
      const numGames = Math.min(200, Math.max(1, parseInt(battleGamesInput.value) || 50));
      const useVizMode = document.getElementById('battle-viz-mode').checked;

      hideBattleModal();
      enterBattleMode();
      battleState = 'loading';

      // Clear old viz data
      localStorage.removeItem('battleData');
      localStorage.removeItem('battleSync');

      // Show loading overlay with ETA (pass agent IDs for estimation, names for display)
      showBattleLoading(numGames, p1Agent, p2Agent, p1Name, p2Name);

      // Update sidebar to show loading state
      battleMatchup.textContent = `${p1Name} vs ${p2Name}`;
      battleProgressText.textContent = 'Computing...';
      battlePlayBtn.disabled = true;

      try {
        const res = await fetch('/api/ai-battle/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            player1Agent: p1Agent,
            player2Agent: p2Agent,
            numGames: numGames
          })
        });

        if (!res.ok) {
          const errBody = await res.text();
          throw new Error(`Server returned ${res.status}: ${errBody}`);
        }

        battleData = await res.json();
        battleState = 'paused';
        battleGameIndex = 0;
        battleTurnIndex = 0;
        battleWins = [0, 0];

        // Hide loading overlay
        hideBattleLoading();

        // If visualizer mode, store data and open visualizer in new window
        if (useVizMode) {
          // Strip activations to avoid localStorage quota issues
          const strippedData = {
            ...battleData,
            games: battleData.games.map(g => ({
              ...g,
              turns: g.turns.map(t => ({ ...t, activations: null }))
            }))
          };
          try {
            localStorage.setItem('battleData', JSON.stringify(strippedData));
            localStorage.setItem('battleSync', JSON.stringify({
              gameIndex: 0, turnIndex: 0, wins: [0, 0], speed: battleSpeed
            }));
          } catch (e) {
            console.warn('Could not store battle data in localStorage:', e);
          }
          // Small delay to ensure localStorage write completes before popup reads
          setTimeout(() => {
            window.vizWindow = window.open('/battle-visualizer?sync=true', 'neural-viz',
              'width=900,height=700,menubar=no,toolbar=no,location=no,status=no');
          }, 100);
        }

        // Update UI with agent names
        battleP0Name.textContent = p1Name;
        battleP1Name.textContent = p2Name;
        battleHandLabel0.textContent = p1Name;
        battleHandLabel1.textContent = p2Name;

        // Enable playback
        battlePlayBtn.disabled = false;
        updateBattleUI();
        renderBattleState();

        // Auto-start playback
        startBattlePlayback();

      } catch (err) {
        console.error('Battle failed:', err);
        hideBattleLoading();
        alert('Failed to start battle: ' + (err.message || String(err)));
        exitBattleMode();
      }
    }

    // Playback control
    function startBattlePlayback() {
      if (battleState === 'complete' || !battleData) return;
      battleState = 'playing';
      battlePlayBtn.textContent = '‚è∏';
      scheduleBattleStep();
    }

    function pauseBattlePlayback() {
      battleState = 'paused';
      battlePlayBtn.textContent = '‚ñ∂';
      if (battlePlaybackTimer) {
        clearTimeout(battlePlaybackTimer);
        battlePlaybackTimer = null;
      }
    }

    function stopBattlePlayback() {
      battleState = 'idle';
      battlePlayBtn.textContent = '‚ñ∂';
      if (battlePlaybackTimer) {
        clearTimeout(battlePlaybackTimer);
        battlePlaybackTimer = null;
      }
    }

    function toggleBattlePlayback() {
      if (battleState === 'playing') {
        pauseBattlePlayback();
      } else if (battleState === 'paused' || battleState === 'complete') {
        // If complete, restart from beginning
        if (battleState === 'complete') {
          battleGameIndex = 0;
          battleTurnIndex = 0;
          battleWins = [0, 0];
        }
        startBattlePlayback();
      }
    }

    function scheduleBattleStep() {
      if (battleState !== 'playing') return;
      battlePlaybackTimer = setTimeout(() => {
        advanceBattleStep();
      }, battleSpeed);
    }

    function advanceBattleStep() {
      if (!battleData || battleState !== 'playing') return;

      const games = battleData.games;
      if (battleGameIndex >= games.length) {
        battleState = 'complete';
        battlePlayBtn.textContent = '‚Üª';
        return;
      }

      const currentGame = games[battleGameIndex];
      const turns = currentGame.turns;

      // Advance to next turn
      battleTurnIndex++;

      if (battleTurnIndex >= turns.length) {
        // Game complete - update wins and move to next game
        if (currentGame.winner >= 0) {
          battleWins[currentGame.winner]++;
        }
        battleGameIndex++;
        battleTurnIndex = 0;

        // Check if all games complete
        if (battleGameIndex >= games.length) {
          battleState = 'complete';
          battlePlayBtn.textContent = '‚Üª';
          updateBattleUI();
          renderBattleState();
          return;
        }
      }

      updateBattleUI();
      renderBattleState();
      syncBattleToViz();
      scheduleBattleStep();
    }

    // Sync battle state to visualizer window via sessionStorage
    function syncBattleToViz() {
      if (window.vizWindow && !window.vizWindow.closed) {
        localStorage.setItem('battleSync', JSON.stringify({
          gameIndex: battleGameIndex,
          turnIndex: battleTurnIndex,
          wins: battleWins,
          speed: battleSpeed,
          state: battleState
        }));
      }
    }

    function updateBattleUI() {
      if (!battleData) return;

      const totalGames = battleData.games.length;
      const currentGame = battleGameIndex + 1;
      const progressPct = (battleGameIndex / totalGames) * 100;

      // Update progress
      battleProgressFill.style.width = `${progressPct}%`;
      battleProgressText.textContent = `Game ${Math.min(currentGame, totalGames)} / ${totalGames}`;

      // Update wins
      battleP0Wins.textContent = battleWins[0];
      battleP1Wins.textContent = battleWins[1];

      // Update win rate
      const totalWins = battleWins[0] + battleWins[1];
      if (totalWins > 0) {
        const p0Pct = Math.round((battleWins[0] / totalWins) * 100);
        const p1Pct = 100 - p0Pct;
        battleWinrateP0.style.width = `${p0Pct}%`;
        battleWinrateP1.style.width = `${p1Pct}%`;
        battleWinrateP0Pct.textContent = `${p0Pct}%`;
        battleWinrateP1Pct.textContent = `${p1Pct}%`;
      } else {
        battleWinrateP0.style.width = '50%';
        battleWinrateP1.style.width = '50%';
        battleWinrateP0Pct.textContent = '-';
        battleWinrateP1Pct.textContent = '-';
      }
    }

    function renderBattleState() {
      if (!battleData) return;

      const games = battleData.games;
      if (battleGameIndex >= games.length) {
        // Show final state of last game
        const lastGame = games[games.length - 1];
        const lastTurn = lastGame.turns[lastGame.turns.length - 1];
        renderBattleTurn(lastTurn.state, lastTurn.activePlayer);
        return;
      }

      const currentGame = games[battleGameIndex];
      const turns = currentGame.turns;
      const turnIdx = Math.min(battleTurnIndex, turns.length - 1);
      const turn = turns[turnIdx];

      renderBattleTurn(turn.state, turn.activePlayer);
    }

    function renderBattleTurn(state, activePlayer) {
      // Highlight active player hand
      battleHand0.classList.toggle('active-player', activePlayer === 0);
      battleHand1.classList.toggle('active-player', activePlayer === 1);

      // Update header turn badge
      const p1Name = battleP0Name.textContent;
      const p2Name = battleP1Name.textContent;
      turnBadge.classList.remove('your-turn', 'ai-turn');
      if (state.isTerminal) {
        turnBadge.classList.add('ai-turn');
        turnText.textContent = 'Game Over';
      } else {
        turnBadge.classList.add(activePlayer === 0 ? 'your-turn' : 'ai-turn');
        turnText.textContent = activePlayer === 0 ? `${p1Name}'s Turn` : `${p2Name}'s Turn`;
      }

      // Calculate and update current game scores in header
      const gameScores = [0, 0];
      if (state.zones && state.zones.beastyBar) {
        state.zones.beastyBar.forEach(card => {
          gameScores[card.owner] += card.points;
        });
      }
      scoreLabels[0].textContent = p1Name;
      scoreLabels[1].textContent = p2Name;
      scoreValues[0].textContent = gameScores[0];
      scoreValues[1].textContent = gameScores[1];

      // Highlight active player in scoreboard
      scoreItems.forEach(el => el.classList.remove('active'));
      if (!state.isTerminal) {
        scoreItems[activePlayer].classList.add('active');
      }

      // Render hands
      renderBattleHand(battleHandCards0, state.hands[0]);
      renderBattleHand(battleHandCards1, state.hands[1]);

      // Render queue
      renderBattleQueue(state.queue);

      // Render piles
      renderBattlePile(battleHeavenCards, battleHeavenCount, state.zones.beastyBar);
      renderBattlePile(battleHellCards, battleHellCount, state.zones.thatsIt);
    }

    function renderBattleHand(container, cards) {
      container.innerHTML = '';
      if (!cards || !cards.length) {
        container.innerHTML = '<div class="hand-empty">No cards</div>';
        return;
      }
      cards.forEach(card => {
        const el = createCardElement(card, { isHandCard: true });
        container.appendChild(el);
      });
    }

    function renderBattleQueue(cards) {
      battleQueue.innerHTML = '';
      if (!cards || !cards.length) {
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.className = 'queue-slot';
          slot.textContent = i + 1;
          battleQueue.appendChild(slot);
        }
        return;
      }
      cards.forEach(card => {
        const el = createCardElement(card, {});
        battleQueue.appendChild(el);
      });
    }

    function renderBattlePile(container, countEl, cards) {
      countEl.textContent = cards ? cards.length : 0;
      container.innerHTML = '';
      if (!cards || !cards.length) {
        container.innerHTML = '<div class="pile-empty">Empty</div>';
        return;
      }
      [...cards].reverse().forEach(card => {
        const el = document.createElement('div');
        el.className = 'pile-card';
        el.innerHTML = `
          <span class="pile-card-owner" data-owner="${card.owner}"></span>
          <span class="pile-card-name">${card.species}</span>
          <span class="pile-card-pts">+${card.points}</span>
        `;
        container.appendChild(el);
      });
    }

    // Battle event listeners
    aiBattleBtn.addEventListener('click', showBattleModal);
    battleCancelBtn.addEventListener('click', hideBattleModal);
    battleStartBtn.addEventListener('click', startBattle);
    battlePlayBtn.addEventListener('click', toggleBattlePlayback);
    battleExitBtn.addEventListener('click', exitBattleMode);

    battleModal.addEventListener('click', (e) => {
      if (e.target === battleModal) hideBattleModal();
    });

    battleSpeedSlider.addEventListener('input', () => {
      battleSpeed = parseInt(battleSpeedSlider.value);
      battleSpeedValue.textContent = `${battleSpeed}ms`;
    });

    // ===================== Splash Screen =====================

    const splash = document.getElementById('splash');
    const splashWatch = document.getElementById('splash-watch');
    const splashPlay = document.getElementById('splash-play');

    function hideSplash() {
      splash.classList.add('hidden');
    }

    // "Watch AI vs AI Battle" ‚Äî auto-start neural vs heuristic battle
    splashWatch.addEventListener('click', async () => {
      hideSplash();
      hideModal();
      // Load battle agents, find neural and heuristic
      try {
        const res = await fetch('/api/ai-agents/battle');
        if (res.ok) {
          const agents = await res.json();
          // Populate selects so battle code works
          battleP1Select.innerHTML = '';
          battleP2Select.innerHTML = '';
          agents.forEach(agent => {
            const opt1 = document.createElement('option');
            opt1.value = agent.id;
            opt1.textContent = agent.name;
            battleP1Select.appendChild(opt1);
            const opt2 = document.createElement('option');
            opt2.value = agent.id;
            opt2.textContent = agent.name;
            battleP2Select.appendChild(opt2);
          });

          // Pick neural agent (prefer ppo_iter949) and heuristic
          const neuralAgent = agents.find(a => a.id.includes('neural') || a.id.includes('ppo_iter949'))
                           || agents.find(a => a.id.includes('ppo'));
          const heuristicAgent = agents.find(a => a.id === 'heuristic')
                              || agents.find(a => a.id !== (neuralAgent ? neuralAgent.id : '') && a.id !== 'random');

          if (neuralAgent) {
            battleP1Select.value = neuralAgent.id;
          }
          if (heuristicAgent) {
            battleP2Select.value = heuristicAgent.id;
          }

          // Set 10 games for quick demo
          battleGamesInput.value = 10;
          // Start the battle directly (skip modal)
          await startBattle();
          // Auto-play after a short delay
          setTimeout(() => {
            if (battleState === 'paused') {
              battlePlayBtn.click();
            }
          }, 500);
        }
      } catch (err) {
        console.error('Failed to auto-start battle:', err);
      }
    });

    // "Play Against the AI" ‚Äî start a game vs neural agent immediately
    splashPlay.addEventListener('click', async () => {
      hideSplash();
      hideModal();
      // Load agents and start game vs best neural agent
      try {
        const res = await fetch('/api/ai-agents');
        if (res.ok) {
          const agents = await res.json();
          aiSelect.innerHTML = '';
          agents.forEach(agent => {
            const opt = document.createElement('option');
            opt.value = agent.id;
            opt.textContent = agent.name;
            aiSelect.appendChild(opt);
          });
          // Pick neural agent
          const neuralAgent = agents.find(a => a.id.includes('neural') || a.id.includes('ppo_iter949'))
                           || agents.find(a => a.id.includes('ppo'));
          if (neuralAgent) {
            aiSelect.value = neuralAgent.id;
          }
        }
      } catch (err) {
        console.error('Failed to load agents:', err);
      }
      // Start game immediately
      await startNewGame();
    });

    // URL param support: ?mode=battle or ?mode=play
    const urlParams = new URLSearchParams(window.location.search);
    const autoMode = urlParams.get('mode');
    if (autoMode === 'battle') {
      splashWatch.click();
    } else if (autoMode === 'play') {
      splashPlay.click();
    }

    // Init
    refreshState();
  </script>
</body>
</html>
